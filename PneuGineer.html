<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PneuGineer - Standalone</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #f7f7f9;
      --panel: #ececf1;
      --ink: #111;
      --muted: #666;
      --accent: #d00;
      --port: #0a74ff;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; background: var(--bg); color: var(--ink); }
    .app { display: grid; grid-template-columns: 220px 1fr; height: 100vh; }
    .sidebar { background: var(--panel); border-right: 1px solid #ccc; padding: 10px; overflow: auto; }
    .sidebar h2 { margin: 6px 0 10px; font-size: 16px; }
    .btn { display: block; width: 100%; margin: 6px 0; padding: 8px 10px; border: 1px solid #bbb; background: #fff; cursor: pointer; border-radius: 6px; text-align: left; }
    .btn:hover { background: #f8f8ff; }

    .workspace { position: relative; overflow: hidden; }
    .layer { position: absolute; inset: 0; }
    #connLayer { z-index: 0; }
    #compLayer { z-index: 1; }
    .comp { position: absolute; transform: translate(-50%, -50%); user-select: none; }
    .label { position: absolute; top: -18px; left: 0; right: 0; text-align: center; font-size: 12px; color: var(--muted); pointer-events: none; }
    svg.compSvg { display: block; overflow: visible; }
    .port { fill: #fff; stroke: var(--port); stroke-width: 1.5; cursor: crosshair; }
    .port:hover { fill: #e8f1ff; }
    .wire { stroke: #000; stroke-width: 2; fill: none; }
    .wire.active { stroke: var(--accent); stroke-dasharray: 6 6; }
    .wire.selected { stroke: #d00; stroke-width: 3; stroke-dasharray: 4 4; }
    .draggable { cursor: move; }
    .hint { position: absolute; bottom: 8px; left: 8px; padding: 6px 8px; font-size: 12px; color: #333; background: #ffffffcc; border: 1px solid #ddd; border-radius: 6px; z-index: 3; }

    /* Help modal + FAB */
    .help-fab {
      position: absolute; right: 14px; bottom: 14px; z-index: 4;
      border: 1px solid #c8d3ff; background: #eff3ff; color: #234;
      padding: 10px 12px; border-radius: 999px; font-weight: 600; cursor: pointer;
      box-shadow: 0 6px 14px rgba(0,0,0,.12);
    }
    .help-fab:hover { background:#e6edff; }

    dialog.help-dialog {
      width: min(1100px, 92vw);
      max-height: min(86vh, 900px);
      border: 0; border-radius: 14px; padding: 0; overflow: hidden;
      box-shadow: 0 30px 80px rgba(0,0,0,.25);
    }
    dialog.help-dialog::backdrop { background: rgba(0,0,0,.35); backdrop-filter: blur(2px); }
    .help-head {
      display:flex; align-items:center; gap:10px;
      background:#eef4ff; border-bottom:1px solid #dfe7ff; padding: 12px 16px;
      font-weight: 700;
    }
    .help-body { padding: 14px 16px; background:#f9fbff; color:#10223d; }
    .help-grid { display:grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    @media (max-width: 1024px){ .help-grid{ grid-template-columns: 1fr; } }
    .help-body h3 { margin:1rem 0 .35rem; font-size:16px; }
    .help-body code { background:#eef3ff; padding:.1rem .35rem; border-radius:6px; }
    .kbd { display:inline-block; padding:.1rem .45rem; border:1px solid #cdd7ff; border-bottom-width:2px; border-radius:6px; background:#fff; font-size:12px; }
    .pill { display:inline-block; padding:.05rem .45rem; border-radius:999px; background:#e8f1ff; border:1px solid #cfe0ff; font-size:12px; }
    .help-foot { display:flex; justify-content:flex-end; gap:8px; padding: 10px 12px; background:#f2f5ff; border-top:1px solid #dfe7ff; }
    .help-close { padding: 8px 12px; border-radius: 8px; border:1px solid #ccd8ff; background:#fff; cursor:pointer; }
    .help-close:hover { background:#f7f9ff; }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h2>Component Library</h2>
      <!-- Component buttons; other controls (Play/Pause, Step, Stop, Undo/Redo, Save/Load, Toggle Grid) are injected by main.js -->
      <button class="btn" id="addValve52">➕ 5/2 valve</button>
      <button class="btn" id="addCylDouble">➕ Cylinder, double-acting</button>
      <button class="btn" id="addCylSingle">➕ Cylinder, single-acting</button>
      <button class="btn" id="addSource">➕ Pressure source</button>
      <button class="btn" id="addAnd">➕ AND valve</button>
      <button class="btn" id="addOr">➕ OR valve</button>
      <button class="btn" id="addLimit32">➕ 3/2 limit valve</button>
      <button class="btn" id="addPush32">➕ 3/2 push button</button>
      <button class="btn" id="addAir32">➕ 3/2 air-piloted</button>
      <hr>
      <!-- Play/Pause, Step, Stop, Undo, Redo, Save, Load, Toggle Grid will be added via ensureButton() -->
    </aside>

    <main class="workspace">
      <svg id="connLayer" class="layer"></svg>
      <div id="compLayer" class="layer"></div>
      <div class="hint">Tip: press <b>?</b> for help. Connect P → valve → cylinder. Cylinders expose signals a0/a1 for limit valves.</div>

      <!-- Floating help button -->
      <button id="helpToggle" class="help-fab">? Help</button>
    </main>
  </div>

  <!-- Help modal -->
  <dialog id="helpDialog" class="help-dialog">
    <div class="help-head">Help & Quick Guide</div>
    <div class="help-body">
      <div class="help-grid">
        <div>
          <h3>Components & Modes</h3>
          <ul>
            <li>Create: <span class="pill">Pressure Source</span>, <span class="pill">5/2 Valve</span>, <span class="pill">Cylinder (DA)</span>, <span class="pill">Cylinder (Single-acting)</span>, <span class="pill">AND</span>, <span class="pill">OR</span>, <span class="pill">3/2 Limit</span>, <span class="pill">3/2 Push Button</span>, <span class="pill">3/2 Air-Piloted</span>.</li>
            <li>Drag to move components (only in <strong>STOP</strong> mode).</li>
            <li><strong>PLAY</strong> runs simulation, <strong>PAUSE</strong> freezes, <strong>STOP</strong> clears overlay & locks editing.</li>
            <li>5/2 can be toggled manually in <strong>PLAY</strong> (click inside a box). Pilots <code>12</code>/<code>14</code> switch on pressure pulses.</li>
            <li>3/2 air-piloted uses pilot <code>12</code> with triangle + horizontal link outside the housing.</li>
          </ul>

          <h3>Link Ports & Junctions</h3>
          <ul>
            <li>Click a port → crosshair → click the next port to create a wire.</li>
            <li>While linking: clicking on a wire creates a <em>junction (J)</em> and connects there. The wire is split automatically.</li>
            <li>Ports have hover priority over wires.</li>
            <li>Wires are orthogonal. Pilot ports <code>12</code>/<code>14</code> (5/2) and <code>12</code> (air 3/2) use horizontal entry stubs that follow valve displacement.</li>
          </ul>

          <h3>Edit Wires</h3>
          <ul>
            <li>Double-click on a wire to insert a bend (H/V). Right-click for a context menu to add/remove/clear segments.</li>
            <li>Select a wire to reveal square handles on inner segments; drag to move the segment.</li>
            <li>Pilot stubs (12/14 on 5/2, 12 on air 3/2) have draggable handles to adjust stub length.</li>
          </ul>
        </div>

        <div>
          <h3>Selection, Copy & Paste</h3>
          <ul>
            <li>Drag on empty space to create a <em>marquee</em>. Release to select. <span class="kbd">Shift</span> adds to selection.</li>
            <li><span class="kbd">Ctrl</span>/<span class="kbd">⌘</span>+<span class="kbd">C</span> copy, <span class="kbd">X</span> cut, <span class="kbd">V</span> paste near the last click.</li>
            <li>Copied wires retain orthogonal bends; manual points follow correctly.</li>
            <li><span class="kbd">Delete</span>/<span class="kbd">Backspace</span> removes selection.</li>
          </ul>

          <h3>Pressure Overlay (bar)</h3>
          <ul>
            <li>In <strong>PLAY</strong>/<strong>PAUSE</strong> each wire shows pressure in <em>bar</em>; active wires blink red.</li>
            <li>Ports show a tooltip with current pressure (<code>X: 0…6 bar</code>).</li>
            <li>Model: source <strong>6.0 bar</strong>, exhaust <strong>0 bar</strong>, pressure spreads via the graph.</li>
          </ul>
        </div>
      </div>

      <h3>Tips</h3>
      <ul>
        <li>Press <strong>?</strong> to open/close this help.</li>
            <li>Single-acting cylinder instances have a small mode toggle on the label: <strong>Push</strong> (A port at the cap end) or <strong>Pull</strong> (A port moved to the rod end and the cylinder defaults to extended).</li>
        <li><strong>ESC</strong> cancels linking.</li>
        <li>Ports win hover when a wire passes nearby.</li>
        <li>Use the sidebar for <em>Play/Pause</em>, <em>Step</em>, <em>Stop & reset</em>, <em>Undo/Redo</em>, <em>Save/Load</em>, and <em>Toggle grid</em>.</li>
      </ul>
    </div>
    <div class="help-foot">
      <button class="help-close" value="cancel">Close</button>
    </div>
  </dialog>

  <!-- Bundled JS -->
  <script>
// js/airValve32.js
// Air-piloted 3/2 with spring return, built to MATCH the pushButton32 geometry.
// - Whole valve "mover" (frame, inner boxes, pilot wall/triangle, spring, AND pilot port 14) slides.
// - Ports 1/2/3 are static (as in pushButton32).
// - Horizontal pilot link goes FROM the left wall (x=0) TO port 14 (x<0), inside the mover.
//
// States (same semantics as pushbutton):
//   ACTIVE (left cell under the ports):   2 → 1,   3 is blocked (T)
//   INACTIVE (right cell under the ports): 2 → 3,   1 is blocked (T)
//
// Public API:
//   addAirValve32(x, y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid)
// Component object:
//   comp.type === 'airValve32'
//   comp.state.active : boolean
//   comp.setActive(bool)  // also aliased as setState(0/1)

function addAirValve32(
  x, y,
  compLayer, components,
  handlePortClick, makeDraggable, redrawConnections,
  uid
){
  const id = uid();

  // ==== Geometry (same basis as pushButton32) ====
  const W = 140, H = 60;
  const NS = 'http://www.w3.org/2000/svg';
  const midX = W / 2;

  // Static ports (1/2/3) — identical positions to pushButton32
  const insetRight = Math.round((W - midX) * 0.25); // ~¼ into right half
  const P2 = { cx: midX + insetRight, cy: -10  };   // 2 (top)
  const P1 = { cx: midX + insetRight, cy: H + 10 }; // 1 (bottom)
  const P3 = { cx: W - 12,            cy: H + 10 }; // 3 (bottom right)

  // Mirror positions for the left cell graphics
  const L2 = { cx: insetRight, cy: P2.cy };
  const L1 = { cx: insetRight, cy: P1.cy };
  const L3 = { cx: midX - 12,  cy: P3.cy };

  // Pilot port 14: local coords relative to the MOVER (so it moves with the valve)
  const P14_LOCAL = { cx: -40, cy: H/2 }; // to the left of the body wall (x=0 in mover)

  // ==== Root wrapper ====
  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = '';
  el.appendChild(label);

  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  W);
  svg.setAttribute('height', H);
  svg.style.overflow = 'visible';

  // ---- defs: arrow head (same as pushbutton) ----
  const defs = document.createElementNS(NS,'defs');
  const marker = document.createElementNS(NS,'marker');
  marker.setAttribute('id','arrow');
  marker.setAttribute('markerWidth','10');
  marker.setAttribute('markerHeight','10');
  marker.setAttribute('refX','9');
  marker.setAttribute('refY','5');
  marker.setAttribute('orient','auto');
  const mpath = document.createElementNS(NS,'path');
  mpath.setAttribute('d','M 0 0 L 10 5 L 0 10 z');
  mpath.setAttribute('fill','#000');
  marker.appendChild(mpath);
  defs.append(marker);
  svg.appendChild(defs);

  // ==== MOVER: everything that slides (frame, inner boxes, pilot wall/triangle, spring, pilot port 14 + link) ====
  const mover = document.createElementNS(NS,'g');

  // Body frame
  const body = document.createElementNS(NS,'rect');
  body.setAttribute('x',0); body.setAttribute('y',0);
  body.setAttribute('width',W); body.setAttribute('height',H);
  body.setAttribute('fill','#fff'); body.setAttribute('stroke','#000');
  body.setAttribute('stroke-width','2');

  // helpers
  const path = (d, opts={})=>{
    const p = document.createElementNS(NS,'path');
    p.setAttribute('d', d);
    p.setAttribute('fill', 'none');
    p.setAttribute('stroke', opts.stroke || '#000');
    p.setAttribute('stroke-width', opts.sw || 2);
    if (opts.arrow === 'end')   p.setAttribute('marker-end','url(#arrow)');
    if (opts.arrow === 'start') p.setAttribute('marker-start','url(#arrow)');
    return p;
  };
  const tBlock = (xCenter, yBar, yStemEnd)=>{
    const frag = document.createDocumentFragment();
    frag.appendChild(path(`M ${xCenter-10} ${yBar} L ${xCenter+10} ${yBar}`));
    frag.appendChild(path(`M ${xCenter} ${yBar} L ${xCenter} ${yStemEnd}`));
    return frag;
  };

  // Inner two boxes
  const boxLeft  = document.createElementNS(NS,'rect');
  boxLeft.setAttribute('x', 0); boxLeft.setAttribute('y', 0);
  boxLeft.setAttribute('width', midX); boxLeft.setAttribute('height', H);
  boxLeft.setAttribute('fill','#fff'); boxLeft.setAttribute('stroke','#000');
  boxLeft.setAttribute('stroke-width','1.6');

  const boxRight = document.createElementNS(NS,'rect');
  boxRight.setAttribute('x', midX); boxRight.setAttribute('y', 0);
  boxRight.setAttribute('width', midX); boxRight.setAttribute('height', H);
  boxRight.setAttribute('fill','#fff'); boxRight.setAttribute('stroke','#000');
  boxRight.setAttribute('stroke-width','1.6');

  // Left cell (ACTIVE): 2 → 1, block 3
  const gLeft = document.createElementNS(NS,'g');
  gLeft.appendChild(path(`M ${L1.cx} ${L1.cy - 10} L ${L2.cx} ${L2.cy + 10}`, { arrow:'end' }));
  gLeft.appendChild(tBlock(L3.cx, H-18, L3.cy - 8));

  // Right cell (INACTIVE): 2 → 3, block 1
  const gRight = document.createElementNS(NS,'g');
  gRight.appendChild(path(`M ${P2.cx} ${P2.cy + 10} L ${P3.cx} ${P3.cy - 10}`, { arrow:'end' }));
  gRight.appendChild(tBlock(P1.cx, H-18, P1.cy - 8));

  // Spring (right wall), follows the mover — same style as pushbutton
  const spring = document.createElementNS(NS,'g');
  spring.setAttribute('transform', `translate(${W}, ${H/2})`);
  spring.append(
    path(`M 0 0 L 20 0`),
    path(`M 20 0 l 10 -10 l 10 20 l 10 -20 l 10 20`)
  );

  // Pilot wall: vertical bar + inward-pointing triangle at the LEFT body wall (x=0) — lives on the mover
  const pilotWall = document.createElementNS(NS,'g');
  // pilotWall.appendChild(path(`M 0 14 L 0 ${H-14}`)); // vertical bar
  pilotWall.appendChild(path(
    `M -26 ${H/2+8} 
    L -6 ${H/2} 
    L -26 ${H/2 - 8} 
    L -26 ${H/2 + 8} Z`, 
    { stroke:'#000', sw:2 })); // inward triangle

  // Pilot port 14 (MOVES with mover)
  const port14El = document.createElementNS(NS,'circle');
  port14El.setAttribute('class','port');
  port14El.setAttribute('r', 6);
  port14El.setAttribute('cx', P14_LOCAL.cx);
  port14El.setAttribute('cy', P14_LOCAL.cy);
  port14El.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, '14', port14El); });

  // Pilot link: FROM wall (x=0) TO port 14 (x<0) — inside mover
  const pilotLink = path(`M -26 ${P14_LOCAL.cy} L ${P14_LOCAL.cx}  ${P14_LOCAL.cy}`);
  const pilotLink2 = path(`M 0 ${P14_LOCAL.cy} L -6  ${P14_LOCAL.cy}`);

  // Assemble mover
  mover.append(
    body, boxLeft, boxRight, gLeft, gRight,
    pilotWall, pilotLink, pilotLink2, port14El, spring
  );
  svg.appendChild(mover);

  // ==== STATIC PORTS (1/2/3) ====
  const makePort = (pos, key)=>{
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port');
    c.setAttribute('r', 6);
    c.setAttribute('cx', pos.cx);
    c.setAttribute('cy', pos.cy);
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });
    return c;
  };
  const port2El  = makePort(P2,  '2');
  const port1El  = makePort(P1,  '1');
  const port3El  = makePort(P3,  '3');
  svg.append(port2El, port1El, port3El);

  // ==== State / programmatic control (pilot-driven) ====
  let isActive = false; // ACTIVE => left cell under ports (2→1). INACTIVE => right cell (2→3)
  let moverDx  = 0;

  function applyTransforms(active){
    moverDx = active ? midX : 0;
    mover.setAttribute('transform', `translate(${moverDx}, 0)`);
    // update cached absolute cx for moving pilot port (used by wiring)
    comp.ports['14'].cx = P14_LOCAL.cx + moverDx;
    comp.ports['14'].cy = P14_LOCAL.cy;
  }

  function setActive(a){
    if (isActive === a) return;
    isActive = a;
    comp.state.active = a;
    applyTransforms(a);
    redrawConnections();
  }

  // ==== Component object ====
  const comp = {
    id, type: 'airValve32',
    el, x, y,
    svgW: W, svgH: H, gx: 0, gy: 0,
    ports: {
      '1':  { cx: P1.cx,          cy: P1.cy,          el: port1El  },
      '2':  { cx: P2.cx,          cy: P2.cy,          el: port2El  },
      '3':  { cx: P3.cx,          cy: P3.cy,          el: port3El  },
      '14': { cx: P14_LOCAL.cx,   cy: P14_LOCAL.cy,   el: port14El } // will be updated by applyTransforms()
    },
    state: { active: false },
    setActive,
    // Backward-compat alias if main.js calls setState(0/1)
    setState(s){ this.setActive(!!s); },
    recompute(){ applyTransforms(isActive); }
  };

  // Mount
  el.appendChild(svg);
  compLayer.appendChild(el);
  el.style.left = `${x}px`; el.style.top  = `${y}px`;

  makeDraggable(comp);
  components.push(comp);

  // Initial pose (INACTIVE)
  applyTransforms(false);

  return comp;
}

// js/andValve.js
// AND (Two-pressure) – ISO/Festo style.
// Port layout: A (left side), B (right side), OUT (top).
// Links: A/B enter horizontally from the sides, OUT exits vertically from the top.

const SCALE_andValve = 1;

function addAndValve(
  x, y,
  compLayer, components,
  handlePortClick, makeDraggable, redrawConnections, uid
){
  const id = uid();
  const s = (n)=> n * SCALE_andValve;

  // Geometri
  const SVG_W=200, SVG_H=180, GX=10, GY=20;
  const HUS_X=40, HUS_Y=60, HUS_W=100, HUS_H=60;

  const NS = 'http://www.w3.org/2000/svg';

  // Rot
  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  s(SVG_W));
  svg.setAttribute('height', s(SVG_H));

  const g = document.createElementNS(NS,'g');
  g.setAttribute('transform', `translate(${s(GX)},${s(GY)})`);

  // Hjälpare
  const line = (x1,y1,x2,y2)=>{
    const l = document.createElementNS(NS,'line');
    l.setAttribute('x1', s(x1)); l.setAttribute('y1', s(y1));
    l.setAttribute('x2', s(x2)); l.setAttribute('y2', s(y2));
    l.setAttribute('stroke','#000'); l.setAttribute('stroke-width', s(2));
    return l;
  };
  const rect = (x,y,w,h)=>{
    const r = document.createElementNS(NS,'rect');
    r.setAttribute('x', s(x)); r.setAttribute('y', s(y));
    r.setAttribute('width', s(w)); r.setAttribute('height', s(h));
    r.setAttribute('fill','#fff'); r.setAttribute('stroke','#000'); r.setAttribute('stroke-width', s(2));
    return r;
  };

  // Hus
  const hus = rect(HUS_X, HUS_Y, HUS_W, HUS_H);

  const yMid   = HUS_Y + HUS_H/2;
  const leftX  = HUS_X + 35;
  const rightX = HUS_X + HUS_W - 35;

  // Check valves toward the center (simple drawing)
  const lBlock1 = line(leftX-20,   HUS_Y, leftX-20,   HUS_Y+23);
  const lShuttle = line(leftX-27,   HUS_Y+15, leftX-27,   HUS_Y+HUS_H-15);
  const lBlock2 = line(leftX-20,   HUS_Y+HUS_H, leftX-20,   HUS_Y+HUS_H-23);

  const rBlock1 = line(rightX+20,  HUS_Y, rightX+20, HUS_Y+23);
  const rShuttle = line(rightX+27,   HUS_Y+15, rightX+27,   HUS_Y+HUS_H-15);
  const rBlock2 = line(rightX+20, HUS_Y+HUS_H, rightX+20, HUS_Y+HUS_H-23);

  const hShuttle = line(leftX-27,  yMid, rightX+27,   yMid);

  // === Port points: A (left), B (right), OUT (top) ===
  const LEFT_PORT_X  = HUS_X - 20;           // port center left
  const RIGHT_PORT_X = HUS_X + HUS_W + 20;   // port center right
  const TOP_PORT_Y   = HUS_Y - 20;           // portcentrum ovanför hus

  const A   = { cx: LEFT_PORT_X,  cy: yMid };
  const B   = { cx: RIGHT_PORT_X, cy: yMid };
  const OUT = { cx: HUS_X + HUS_W/2, cy: TOP_PORT_Y };

  // Inre anslutningslinjer
  const aLine = line(HUS_X,        A.cy,   A.cx+6, A.cy);
  const bLine = line(HUS_X+HUS_W,  B.cy,   B.cx-6, B.cy);
  const outLn = line(OUT.cx,       OUT.cy+6, OUT.cx, HUS_Y);

  g.append(hus,
           lBlock1, lShuttle, lBlock2,
           rBlock1, rShuttle, rBlock2,
           hShuttle,
           aLine, bLine, outLn);

  // Ports (clickable) with smart text placement
  function makePort(key, p, side){ // side: 'L' | 'R' | 'T'
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port'); c.setAttribute('r', s(6));
    c.setAttribute('cx', s(p.cx)); c.setAttribute('cy', s(p.cy));
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });

    const t = document.createElementNS(NS,'text');
    if (side==='L'){
      t.setAttribute('x', s(p.cx - 14)); t.setAttribute('y', s(p.cy + 4));
      t.setAttribute('text-anchor','end');
    } else if (side==='R'){
      t.setAttribute('x', s(p.cx + 14)); t.setAttribute('y', s(p.cy + 4));
      t.setAttribute('text-anchor','start');
    } else { // T (top) – flytta OUT-texten lite åt höger
      t.setAttribute('x', s(p.cx + 12));
      t.setAttribute('y', s(p.cy - 10));
      t.setAttribute('text-anchor','start');
    }
    t.setAttribute('font-size', Math.max(9, 11*SCALE_andValve));
    t.textContent = key;

    return { c, t };
  }

  const a   = makePort('A',   A,   'L');
  const b   = makePort('B',   B,   'R');
  const out = makePort('OUT', OUT, 'T');
  g.append(a.c, a.t, b.c, b.t, out.c, out.t);

  // Montera
  svg.appendChild(g);
  el.append(svg);
  compLayer.appendChild(el);

  // Komponent-API
  const comp = {
    id, type:'andValve', el, x, y,
    svgW: s(SVG_W), svgH: s(SVG_H),
    gx: s(GX), gy: s(GY),
    ports: {
      OUT:{ cx: s(OUT.cx), cy: s(OUT.cy), el: out.c },
      A:  { cx: s(A.cx),   cy: s(A.cy),   el: a.c },
      B:  { cx: s(B.cx),   cy: s(B.cy),   el: b.c }
    }
  };

  makeDraggable(comp);
  components.push(comp);
  redrawConnections();
  return comp;
}

// js/checkValve.js
// Check valve. Ports: IN bottom, OUT top. Allows IN→OUT, blocks OUT→IN.
// Scale for ALL check valves:
const SCALE_checkValve = 0.5;

function addCheckValve(
  x, y,
  compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid
){
  const id = uid();
  const s = (n)=> n * SCALE_checkValve;

  const SVG_W=120, SVG_H=140, GX=10, GY=20;

  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = '';

  const NS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  s(SVG_W));
  svg.setAttribute('height', s(SVG_H));

  const g = document.createElementNS(NS,'g');
  g.setAttribute('transform', `translate(${s(GX)},${s(GY)})`);

  // Hus
  const HUS_X=20, HUS_Y=40, HUS_W=80, HUS_H=60;
  const hus = document.createElementNS(NS,'rect');
  hus.setAttribute('x', s(HUS_X));
  hus.setAttribute('y', s(HUS_Y));
  hus.setAttribute('width',  s(HUS_W));
  hus.setAttribute('height', s(HUS_H));
  hus.setAttribute('fill','#fff');
  hus.setAttribute('stroke','#000');
  hus.setAttribute('stroke-width', s(2));

  // Ball + seat (ISO style) – flow upwards
  const cx = HUS_X + HUS_W/2;
  const yMid = HUS_Y + HUS_H/2;
  const ball = document.createElementNS(NS,'circle');
  ball.setAttribute('cx', s(cx));
  ball.setAttribute('cy', s(yMid+6));
  ball.setAttribute('r',  s(5.5));
  ball.setAttribute('fill','#fff');
  ball.setAttribute('stroke','#000');
  ball.setAttribute('stroke-width', s(2));

  const seat = document.createElementNS(NS,'line'); // slanted seat surface ↑
  seat.setAttribute('x1', s(cx-14)); seat.setAttribute('y1', s(yMid-8));
  seat.setAttribute('x2', s(cx+14)); seat.setAttribute('y2', s(yMid));
  seat.setAttribute('stroke','#000'); seat.setAttribute('stroke-width', s(2));

  // Ports: OUT top, IN bottom
  const OUT = { cx: cx, cy: HUS_Y-18 };
  const IN  = { cx: cx, cy: HUS_Y+HUS_H+18 };

  const line = (x1,y1,x2,y2)=>{
    const l = document.createElementNS(NS,'line');
    l.setAttribute('x1', s(x1)); l.setAttribute('y1', s(y1));
    l.setAttribute('x2', s(x2)); l.setAttribute('y2', s(y2));
    l.setAttribute('stroke','#000'); l.setAttribute('stroke-width', s(2));
    return l;
  };

  const outLine = line(OUT.cx, OUT.cy+6, OUT.cx, HUS_Y);
  const inLine  = line(IN.cx,  HUS_Y+HUS_H, IN.cx,  IN.cy-6);

  function makePort(key, p, labelBelow=false){
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port'); c.setAttribute('r', s(6));
    c.setAttribute('cx', s(p.cx)); c.setAttribute('cy', s(p.cy));
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });
    const t = document.createElementNS(NS,'text');
    t.setAttribute('x', s(p.cx));
    t.setAttribute('y', s(labelBelow ? p.cy+18 : p.cy-10));
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-size', Math.max(9, 11*SCALE_checkValve));
    t.textContent = key;
    return { c, t };
  }
  const out = makePort('OUT', OUT, false);
  const inp = makePort('IN',  IN,  true);

  g.append(hus, ball, seat, outLine, inLine, out.c, out.t, inp.c, inp.t);
  svg.appendChild(g);
  el.append(label, svg);
  compLayer.appendChild(el);

  const comp = {
    id, type:'checkValve', el, x, y,
    svgW: s(SVG_W), svgH: s(SVG_H), gx: s(GX), gy: s(GY),
    ports: {
      IN:  { cx: s(IN.cx),  cy: s(IN.cy),  el: inp.c },
      OUT: { cx: s(OUT.cx), cy: s(OUT.cy), el: out.c }
    }
  };

  makeDraggable(comp);
  components.push(comp);
  redrawConnections();
  return comp;
}

// js/cylinderDouble.js
// Double-acting cylinder. Ports: Cap (left bottom), Rod (right bottom).
// Justera storlek för ALLA cylindrar här:
const SCALE_cylinderDouble = 1;

function addCylinderDouble(
  x, y,
  compLayer, components,
  handlePortClick, makeDraggable, redrawConnections, uid,
  getNextCylinderLetter, setSignal   // <-- behövs för auto-namn + signaler
){
  const id = uid();
  const s = (n)=> n * SCALE_cylinderDouble;

  // ===== Init-namn =====
  const initialLetter = (typeof getNextCylinderLetter === 'function')
    ? getNextCylinderLetter()
    : 'A';

  // Kompaktare box
  const SVG_W = 340;
  const SVG_H = 50;
  const GX = 10, GY = 10;

  const W = 220, H = 70;
  const PORT_MARGIN = 6;

  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  // låt etiketten vara klickbar trots global CSS
  label.style.pointerEvents = 'auto';

  const NS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  s(SVG_W));
  svg.setAttribute('height', s(SVG_H));
  svg.style.overflow = 'visible';

  const g = document.createElementNS(NS,'g');
  g.setAttribute('transform', `translate(${s(GX)},${s(GY)})`);

  // Hus
  const body = document.createElementNS(NS,'rect');
  body.setAttribute('x', s(0)); body.setAttribute('y', s(0));
  body.setAttribute('width', s(W)); body.setAttribute('height', s(H));
  body.setAttribute('fill','#fff'); body.setAttribute('stroke','#000');
  body.setAttribute('stroke-width', s(2));

  // Kolv
  const piston = document.createElementNS(NS,'rect');
  piston.setAttribute('x', s(60)); piston.setAttribute('y', s(0));
  piston.setAttribute('width', s(6)); piston.setAttribute('height', s(H));
  piston.setAttribute('fill','#888');

  // Stång
  const rod = document.createElementNS(NS,'rect');
  rod.setAttribute('x', s(66)); rod.setAttribute('y', s(H/2 - 3));
  rod.setAttribute('width', s(W-66)); rod.setAttribute('height', s(6));
  rod.setAttribute('fill','#888');

  // Spets
  const rodTip = document.createElementNS(NS,'rect');
  rodTip.setAttribute('x', s(W));
  rodTip.setAttribute('y', s(H/2 - 6));
  rodTip.setAttribute('width', s(10));
  rodTip.setAttribute('height', s(12));
  rodTip.setAttribute('fill','#666');

  // Portar
  const ports = {
    Cap: { cx: 10,     cy: H + PORT_MARGIN },
    Rod: { cx: W - 10, cy: H + PORT_MARGIN }
  };
  const portEls = {};
  Object.keys(ports).forEach(key=>{
    const p = ports[key];
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port'); c.setAttribute('r', s(6));
    c.setAttribute('cx', s(p.cx)); c.setAttribute('cy', s(p.cy));
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });

    const t = document.createElementNS(NS,'text');
    t.setAttribute('x', s(p.cx)); t.setAttribute('y', s(p.cy - 8));
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-size', Math.max(9, 10*SCALE_cylinderDouble));
    t.textContent = key;

    g.append(c, t);
    portEls[key] = c;
  });

  g.append(body, piston, rod, rodTip);
  svg.appendChild(g);
  el.append(label, svg);
  compLayer.appendChild(el);

  // ===== Komponentobjekt =====
  const comp = {
    id, type:'cylDouble', el, x, y,
    svgW: s(SVG_W), svgH: s(SVG_H), gx: s(GX), gy: s(GY),
    ports: {
      Cap: { cx: s(ports.Cap.cx), cy: s(ports.Cap.cy), el: portEls.Cap },
      Rod: { cx: s(ports.Rod.cx), cy: s(ports.Rod.cy), el: portEls.Rod }
    },
    // Läge (0=indragen, 1=utdragen)
    pos: 0,

    // Namn (bokstav) – init nedan via setLetter
    letter: initialLetter,
    lower: initialLetter.toLowerCase(),

    setPos(alpha){
      this.pos = Math.max(0, Math.min(1, alpha));
      // Kolvens x
      const px = 10 + this.pos*(W-20);

      piston.setAttribute('x', s(px));

      const rodX = px + 6;
      const tipX = px + (W - 10);
      const rodW = Math.max(0, tipX - rodX);

      rod.setAttribute('x', s(rodX));
      rod.setAttribute('width', s(rodW));
      rodTip.setAttribute('x', s(tipX));

      // === Signaler ===
      // Publicera enligt aktuell bokstav (lower)
      if (this.pos <= 0) {          // helt inne
        setSignal(`${this.lower}0`, true);
        setSignal(`${this.lower}1`, false);
      } else if (this.pos >= 1) {   // helt ute
        setSignal(`${this.lower}0`, false);
        setSignal(`${this.lower}1`, true);
      } else {                      // mellanläge
        setSignal(`${this.lower}0`, false);
        setSignal(`${this.lower}1`, false);
      }
    },

    // Change letter (A–Z). Updates label and signal keys.
    setLetter(newLetterRaw){
      if (!newLetterRaw) return;
      const L = String(newLetterRaw).trim().toUpperCase();
  if (!/^[A-Z]$/.test(L)) return; // requires a single letter A–Z

      const prevLower = this.lower;
      const nextLower = L.toLowerCase();

  // Silence old signals so they don't "linger"
      setSignal(`${prevLower}0`, false);
      setSignal(`${prevLower}1`, false);

      this.letter = L;
      this.lower  = nextLower;

  // Update label
      label.textContent = `Cylinder ${this.letter}`;

      // Publicera nya signaler enligt aktuellt läge
      this.setPos(this.pos);
      redrawConnections?.();
    },

    getLetter(){ return this.letter; }
  };

  // Init label & position/signals
  comp.setLetter(initialLetter);
  comp.setPos(comp.pos);

  // ====== UI: Change letter via double-click on the label ======
  label.addEventListener('dblclick', (e)=>{
    e.stopPropagation();
    const answer = window.prompt('Enter cylinder letter (A–Z):', comp.letter);
    if (answer === null) return; // cancelled
    comp.setLetter(answer);
  });

  makeDraggable(comp);
  components.push(comp);
  redrawConnections();
  return comp;
}

// js/cylinderSingle.js
// Single-acting cylinder (spring return).
// Ports: A (pressure). Internal spring returns the piston when no pressure.
// Shares the same letter + signals scheme as your double-acting cylinder:
//   - Signals published: a0 (fully retracted), a1 (fully extended) for current letter.
//   - Double-click label to rename cylinder letter (A–Z).
//
// Public API:
// addCylinderSingle(
//   x, y,
//   compLayer, components,
//   handlePortClick, makeDraggable, redrawConnections, uid,
//   getNextCylinderLetter, setSignal,
//   opts?    // { normallyExtended?: boolean } default false (normally retracted)
// )

const SCALE_cylinderSingle = 1;

function addCylinderSingle(
  x, y,
  compLayer, components,
  handlePortClick, makeDraggable, redrawConnections, uid,
  getNextCylinderLetter, setSignal,
  opts = {}
){
  const id = uid();
  const s = (n)=> n * SCALE_cylinderSingle;

  // Mode: 'push' (default) = extend when A pressurized; 'pull' = retract when A pressurized
  const initialMode = (opts && opts.mode === 'pull') ? 'pull' : 'push';
  // Defaults: normally retracted unless explicitly set; but pull-mode defaults to extended
  const normallyExtended = (opts && typeof opts.normallyExtended !== 'undefined')
    ? !!opts.normallyExtended
    : (initialMode === 'pull');

  // ===== Letter init =====
  const initialLetter = (typeof getNextCylinderLetter === 'function')
    ? getNextCylinderLetter()
    : 'A';

  // Compact overall SVG like your double-acting style
  const SVG_W = 300;
  const SVG_H = 60;
  const GX = 10, GY = 10;

  // Cylinder housing geometry
  const W = 200, H = 70;
  const PORT_MARGIN = 6;

  // --- DOM container ---
  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  label.style.pointerEvents = 'auto'; // allow dblclick edit
  // label contains text and a small mode toggle button
  const labelText = document.createElement('span');
  const modeBtn = document.createElement('button');
  modeBtn.className = 'cylModeBtn';
  modeBtn.style.marginLeft = '6px';
  modeBtn.style.fontSize = '10px';
  modeBtn.style.padding = '2px 6px';
  modeBtn.style.borderRadius = '6px';
  modeBtn.style.cursor = 'pointer';
  modeBtn.title = 'Toggle single-acting mode (push/pull)';
  label.appendChild(labelText);
  label.appendChild(modeBtn);
  el.appendChild(label);

  const NS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  s(SVG_W));
  svg.setAttribute('height', s(SVG_H));
  svg.style.overflow = 'visible';

  const g = document.createElementNS(NS,'g');
  g.setAttribute('transform', `translate(${s(GX)},${s(GY)})`);

  // --- Body ---
  const body = document.createElementNS(NS,'rect');
  body.setAttribute('x', s(0)); body.setAttribute('y', s(0));
  body.setAttribute('width', s(W)); body.setAttribute('height', s(H));
  body.setAttribute('fill','#fff'); body.setAttribute('stroke','#000');
  body.setAttribute('stroke-width', s(2));

  // --- Piston (vertical bar) ---
  const piston = document.createElementNS(NS,'rect');
  piston.setAttribute('x', s(56)); piston.setAttribute('y', s(0));
  piston.setAttribute('width', s(6)); piston.setAttribute('height', s(H));
  piston.setAttribute('fill','#888');

  // --- Rod (horizontal) ---
  const rod = document.createElementNS(NS,'rect');
  rod.setAttribute('x', s(62)); rod.setAttribute('y', s(H/2 - 3));
  rod.setAttribute('width', s(W-62)); rod.setAttribute('height', s(6));
  rod.setAttribute('fill','#888');

  // --- Rod tip (end block) ---
  const rodTip = document.createElementNS(NS,'rect');
  rodTip.setAttribute('x', s(W));
  rodTip.setAttribute('y', s(H/2 - 6));
  rodTip.setAttribute('width', s(10));
  rodTip.setAttribute('height', s(12));
  rodTip.setAttribute('fill','#666');

  // --- Spring (drawn on the right pushing left) ---
  // Fixed anchor at right inner wall; purely cosmetic symbol
  const spring = document.createElementNS(NS,'path');
  const springY = H/2;
  const springX0 = W - 28; // start near right wall
  const seg = 10;
  const springPath = [
    `M ${s(springX0)} ${s(springY)}`,
    `l ${s(-seg)} ${s(-8)}`,
    `l ${s(-seg)} ${s(16)}`,
    `l ${s(-seg)} ${s(-16)}`,
    `l ${s(-seg)} ${s(16)}`
  ].join(' ');
  spring.setAttribute('d', springPath);
  spring.setAttribute('fill','none');
  spring.setAttribute('stroke','#000');
  spring.setAttribute('stroke-width', s(2));

  // --- Ports (only A) ---
  // Position A on left for 'push', on right for 'pull'
  const A_cx = (initialMode === 'pull') ? (W - 12) : 12;
  const ports = { A: { cx: A_cx, cy: H + PORT_MARGIN } };
  const portEls = {};
  const portTextEls = {};
  Object.keys(ports).forEach(key=>{
    const p = ports[key];
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port'); c.setAttribute('r', s(6));
    c.setAttribute('cx', s(p.cx)); c.setAttribute('cy', s(p.cy));
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });

    const t = document.createElementNS(NS,'text');
    t.setAttribute('x', s(p.cx)); t.setAttribute('y', s(p.cy - 8));
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-size', Math.max(9, 10*SCALE_cylinderSingle));
    t.textContent = key;

    g.append(c, t);
    portEls[key] = c;
    portTextEls[key] = t;
  });

  // Mount graphics
  g.append(body, piston, rod, rodTip, spring);
  svg.appendChild(g);
  el.appendChild(svg);
  compLayer.appendChild(el);

  // ===== Component object =====
  const comp = {
    id, type:'cylSingle', el, x, y,
    svgW: s(SVG_W), svgH: s(SVG_H), gx: s(GX), gy: s(GY),
    ports: {
      A: { cx: s(ports.A.cx), cy: s(ports.A.cy), el: portEls.A }
    },

    // Position (0=retracted, 1=extended)
    pos: normallyExtended ? 1 : 0,

  // persistable properties
  mode: initialMode,
  normallyExtended: normallyExtended,

    // Letter / signals
    letter: initialLetter,
    lower: initialLetter.toLowerCase(),

    setPos(alpha){
      this.pos = Math.max(0, Math.min(1, alpha));

      // Piston x: travel range inside body (approx like your double)
      const travelStart = 10;           // where piston is when retracted
      const travelEnd   = W - 20;       // near right
      const px = travelStart + this.pos * (travelEnd - travelStart);

      piston.setAttribute('x', s(px));

      const rodX = px + 6;
      const tipX = px + (W - 10);
      const rodW = Math.max(0, tipX - rodX);

      rod.setAttribute('x', s(rodX));
      rod.setAttribute('width', s(rodW));
      rodTip.setAttribute('x', s(tipX));

      // --- Signals ---
      if (this.pos <= 0) {          // fully retracted
        setSignal(`${this.lower}0`, true);
        setSignal(`${this.lower}1`, false);
      } else if (this.pos >= 1) {   // fully extended
        setSignal(`${this.lower}0`, false);
        setSignal(`${this.lower}1`, true);
      } else {                      // mid
        setSignal(`${this.lower}0`, false);
        setSignal(`${this.lower}1`, false);
      }
    },

    setLetter(newLetterRaw){
      if (!newLetterRaw) return;
      const L = String(newLetterRaw).trim().toUpperCase();
      if (!/^[A-Z]$/.test(L)) return;

      const prevLower = this.lower;
      const nextLower = L.toLowerCase();

      // Clear previous signal keys
      setSignal(`${prevLower}0`, false);
      setSignal(`${prevLower}1`, false);

      this.letter = L;
      this.lower  = nextLower;

  labelText.textContent = `Cylinder ${this.letter} (single-acting)`;
  modeBtn.textContent = this.mode === 'push' ? 'push' : 'pull';

      // Re-publish current state under new keys
      this.setPos(this.pos);
      redrawConnections?.();
    },

    getLetter(){ return this.letter; }
  };

    // Init label & position/signals
  comp.setLetter(initialLetter);
  comp.setPos(comp.pos);

    // expose the mode button so the outer UI can hide/show it during simulation
    comp.modeBtn = modeBtn;

  // mode toggle handler — move port and set default position
  modeBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    comp.mode = (comp.mode === 'push') ? 'pull' : 'push';
    modeBtn.textContent = comp.mode === 'push' ? 'push' : 'pull';

    // move port to other end
    const newCx = (comp.mode === 'pull') ? (W - 12) : 12;
    const pEl = portEls.A; const tEl = portTextEls.A;
    pEl.setAttribute('cx', s(newCx));
    tEl.setAttribute('x', s(newCx));
    comp.ports.A.cx = s(newCx);

    // when switching to pull, default to extended; when switching to push, default to retracted
    comp.normallyExtended = (comp.mode === 'pull');
    comp.setPos(comp.normallyExtended ? 1 : 0);

    redrawConnections?.();
  });

  // Letter edit on dblclick
  label.addEventListener('dblclick', (e)=>{
    e.stopPropagation();
    const answer = window.prompt('Enter cylinder letter (A–Z):', comp.letter);
    if (answer === null) return;
    comp.setLetter(answer);
  });

  makeDraggable(comp);
  components.push(comp);
  redrawConnections();
  return comp;
}

// js/limitValve32.js
// 3/2 limit valve where the whole valve (frame, inner boxes, roller/shaft, spring)
// is shifted using an SVG transform when activated; ports remain in place.
//
// Left cell (ACTIVE): 2→1, 3 blocked
// Right cell (REST):  2→3, 1 blocked
//
// Label: an SVG text element just above the roller (moves with the roller). Shows only the sensor key (e.g. a0).
// Click the label / double-click the component / press 'S' to bind a sensor.
//
// Signature (matches main.js):
// addLimitValve32(x,y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid, getSignal)

function addLimitValve32(
  x, y,
  compLayer, components,
  handlePortClick, makeDraggable, redrawConnections,
  uid,
  getSignal
){
  const id = uid();

  // Geometri
  const W = 140, H = 60;
  const NS = 'http://www.w3.org/2000/svg';
  const midX = W / 2;

  // Port positions (right cell)
  const insetRight = Math.round((W - midX) * 0.25); // ~¼ in i högra halvan
  const P2 = { cx: midX + insetRight, cy: -10  };   // 2 (uppe, mitt ovanför 1)
  const P1 = { cx: midX + insetRight, cy: H + 10 }; // 1 (nere)
  const P3 = { cx: W - 12,            cy: H + 10 }; // 3 (nere höger)

  // Corresponding positions in the left cell (for inner graphics)
  const L2 = { cx: insetRight, cy: P2.cy };
  const L1 = { cx: insetRight, cy: P1.cy };
  const L3 = { cx: midX - 12,  cy: P3.cy };

  // Rot
  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  // Empty HTML label (we don't show a '3/2 valve' text above the component)
  const htmlLabel = document.createElement('div');
  htmlLabel.className = 'label';
  htmlLabel.textContent = ''; // håll tom
  el.appendChild(htmlLabel);

  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  W);
  svg.setAttribute('height', H);
  svg.style.overflow = 'visible'; // rulle/fjäder kan sticka ut

  // --- defs: pilspets ---
  const defs = document.createElementNS(NS,'defs');
  const marker = document.createElementNS(NS,'marker');
  marker.setAttribute('id','arrow');
  marker.setAttribute('markerWidth','10');
  marker.setAttribute('markerHeight','10');
  marker.setAttribute('refX','9');
  marker.setAttribute('refY','5');
  marker.setAttribute('orient','auto');
  const mpath = document.createElementNS(NS,'path');
  mpath.setAttribute('d','M 0 0 L 10 5 L 0 10 z');
  mpath.setAttribute('fill','#000');
  marker.appendChild(mpath);
  defs.append(marker);
  svg.appendChild(defs);

  // === MOVER (allt som ska skjutas: ram, inre lådor, pilar, rulle, fjäder) ===
  const mover = document.createElementNS(NS,'g');

  // Ram
  const body = document.createElementNS(NS,'rect');
  body.setAttribute('x',0); body.setAttribute('y',0);
  body.setAttribute('width',W); body.setAttribute('height',H);
  body.setAttribute('fill','#fff'); body.setAttribute('stroke','#000');
  body.setAttribute('stroke-width','2');

  // Hjälpare
  const path = (d, opts={})=>{
    const p = document.createElementNS(NS,'path');
    p.setAttribute('d', d);
    p.setAttribute('fill', 'none');
    p.setAttribute('stroke', opts.stroke || '#000');
    p.setAttribute('stroke-width', opts.sw || 2);
    if (opts.arrow === 'end')   p.setAttribute('marker-end','url(#arrow)');
    if (opts.arrow === 'start') p.setAttribute('marker-start','url(#arrow)');
    return p;
  };
  const tBlock = (xCenter, yBar, yStemEnd)=>{
    const frag = document.createDocumentFragment();
    frag.appendChild(path(`M ${xCenter-10} ${yBar} L ${xCenter+10} ${yBar}`));
    frag.appendChild(path(`M ${xCenter} ${yBar} L ${xCenter} ${yStemEnd}`));
    return frag;
  };

  // Inner "boxes"
  const boxLeft  = document.createElementNS(NS,'rect');
  boxLeft.setAttribute('x', 0); boxLeft.setAttribute('y', 0);
  boxLeft.setAttribute('width', midX); boxLeft.setAttribute('height', H);
  boxLeft.setAttribute('fill','#fff'); boxLeft.setAttribute('stroke','#000');
  boxLeft.setAttribute('stroke-width','1.6');

  const boxRight = document.createElementNS(NS,'rect');
  boxRight.setAttribute('x', midX); boxRight.setAttribute('y', 0);
  boxRight.setAttribute('width', midX); boxRight.setAttribute('height', H);
  boxRight.setAttribute('fill','#fff'); boxRight.setAttribute('stroke','#000');
  boxRight.setAttribute('stroke-width','1.6');

  // Left cell (ACTIVE): 2→1, 3 blocked (T)
  const gLeft = document.createElementNS(NS,'g');
  gLeft.appendChild(path(`M ${L1.cx } ${L1.cy -10} L ${L2.cx} ${L2.cy + 10}`, { arrow:'end' }));
  gLeft.appendChild(tBlock(L3.cx, H-24, L3.cy-10));

  // Right cell (REST): 2→3, 1 blocked (T)
  const gRight = document.createElementNS(NS,'g');
  gRight.appendChild(path(`M ${P2.cx} ${P2.cy + 10} L ${P3.cx} ${P3.cy - 10}`, { arrow:'end' }));
  gRight.appendChild(tBlock(P1.cx, H-24, P1.cy-10));

  // Rulle + skalen
  const rollerGroup = document.createElementNS(NS,'g');
  rollerGroup.setAttribute('transform', `translate(-34, ${H/2})`);
  rollerGroup.append(
    path(`M -6 -7 L 35 -7`), path(`M -6 7 L 35 7`)
  );
  const rollerOuter = document.createElementNS(NS,'circle');
  rollerOuter.setAttribute('cx', 4); rollerOuter.setAttribute('cy', 0); rollerOuter.setAttribute('r', 13);
  rollerOuter.setAttribute('fill','#fff'); rollerOuter.setAttribute('stroke','#000');
  rollerOuter.setAttribute('stroke-width','2');
  const rollerInner = document.createElementNS(NS,'circle');
  rollerInner.setAttribute('cx', 4); rollerInner.setAttribute('cy', 0);
  rollerInner.setAttribute('r', 6);
  rollerInner.setAttribute('fill','#fff'); rollerInner.setAttribute('stroke','#000');
  rollerInner.setAttribute('stroke-width','2');

  // Label: just above the roller (follows the mover)
  const rollLabel = document.createElementNS(NS,'text');
  rollLabel.setAttribute('x', 4);
  rollLabel.setAttribute('y', -18);
  rollLabel.setAttribute('text-anchor','middle');
  rollLabel.setAttribute('font-size','12');
  rollLabel.style.userSelect = 'none';
  rollLabel.style.cursor = 'pointer';

  rollerGroup.append(rollerOuter, rollerInner, rollLabel);

  // Spring (follows with the mover)
  const spring = document.createElementNS(NS,'g');
  spring.setAttribute('transform', `translate(${W}, ${H/2})`);
  spring.append(
    path(`M 0 0 L 20 0`),
    path(`M 20 0 l 10 -10 l 10 20 l 10 -20 l 10 20 l 10 -20 l 10 20`)
  );

  // Sätt ihop
  mover.append(body, boxLeft, boxRight, gLeft, gRight, rollerGroup, spring);
  svg.appendChild(mover);

  // === PORTS (static) ====================================================
  const makePort = (pos, key)=>{
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port');
    c.setAttribute('r', 6);
    c.setAttribute('cx', pos.cx);
    c.setAttribute('cy', pos.cy);
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });
    return c;
  };
  const port2El = makePort(P2, '2');
  const port1El = makePort(P1, '1');
  const port3El = makePort(P3, '3');
  svg.append(port2El, port1El, port3El);

  // === State / interaction =============================================
  let sensorKey = null;   // 'a0', 'a1', ...
  let manualActive = false;

  function updateLabel(){
    rollLabel.textContent = sensorKey ? sensorKey : '';
  }

  function applyTransforms(active){
    // Aktiv = vänster cell under porterna → flytta hela mover 'midX' åt höger
    const dx = active ? midX : 0;
    mover.setAttribute('transform', `translate(${dx}, 0)`);
  }

  function recompute(){
    const active = sensorKey ? !!getSignal(sensorKey) : manualActive;
    comp.state.active = active;
    applyTransforms(active);
  }

  function promptBind(){
    const k = window.prompt('Enter sensor (e.g. a0, a1, b0, b1):', sensorKey || '');
    if (k !== null){
      setSensor(String(k));
    }
  }

  // === Exponera sensor-getter/setter (för spara/ladda) =====================
  function setSensor(k){
    const s = (k && String(k).trim()) ? String(k).trim().toLowerCase() : null;
    sensorKey = s;
    updateLabel();
    recompute();
    redrawConnections();
  }
  function getSensor(){
    return sensorKey || null;
  }

  // Manuell toggle (om ingen sensor): klick i vänstra halvan
  svg.addEventListener('click', (e)=>{
    const rect = svg.getBoundingClientRect();
    const localX = e.clientX - rect.left;
    if (sensorKey) return;        // låst till sensor
    if (localX < midX){
      manualActive = !manualActive;
      recompute();
      redrawConnections();
    }
  });

  // Bindning via S / dubbelklick / klick på etikett
  svg.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase()==='s') promptBind(); });
  svg.setAttribute('tabindex', '0'); svg.style.outline = 'none';
  el.addEventListener('dblclick', (e)=>{ e.stopPropagation(); promptBind(); });
  rollLabel.addEventListener('click', (e)=>{ e.stopPropagation(); promptBind(); });

  // === Komponent-obj =======================================================
  const comp = {
    id, type: 'limit32',
    el, x, y,
    svgW: W, svgH: H, gx: 0, gy: 0,
    ports: {
      '1': { cx: P1.cx, cy: P1.cy, el: port1El },
      '2': { cx: P2.cx, cy: P2.cy, el: port2El },
      '3': { cx: P3.cx, cy: P3.cy, el: port3El }
    },
    state: { active: false },
    recompute,
    // Exponera för main.js (snapshot/load)
    getSensorKey: getSensor,
    setSensorKey: setSensor
  };

  // Mount
  el.appendChild(svg);
  compLayer.appendChild(el);
  comp.x = x; comp.y = y;
  el.style.left = `${x}px`; el.style.top  = `${y}px`;

  makeDraggable(comp);
  components.push(comp);

  // Init
  updateLabel();
  recompute();
  return comp;
}

// js/orValve.js
// OR (Shuttle) – ISO/Festo-stil.
// Port layout: A (left side), B (right side), OUT (top).
// Länkar: A/B horisontellt in från sidorna, OUT vertikalt ned från toppen.

const SCALE_orValve = 1;

function addOrValve(
  x, y,
  compLayer, components,
  handlePortClick, makeDraggable, redrawConnections, uid
){
  const id = uid();
  const s = (n)=> n * SCALE_orValve;

  // Geometry
  const SVG_W=200, SVG_H=180, GX=10, GY=20;
  const HUS_X=40, HUS_Y=60, HUS_W=100, HUS_H=60;

  const NS = 'http://www.w3.org/2000/svg';

  // Root element
  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  s(SVG_W));
  svg.setAttribute('height', s(SVG_H));

  const g = document.createElementNS(NS,'g');
  g.setAttribute('transform', `translate(${s(GX)},${s(GY)})`);

  // Hjälpare
  const line = (x1,y1,x2,y2)=>{
    const l = document.createElementNS(NS,'line');
    l.setAttribute('x1', s(x1)); l.setAttribute('y1', s(y1));
    l.setAttribute('x2', s(x2)); l.setAttribute('y2', s(y2));
    l.setAttribute('stroke','#000'); l.setAttribute('stroke-width', s(2));
    l.setAttribute('vector-effect','non-scaling-stroke');
    return l;
  };
  const rect = (x,y,w,h)=>{
    const r = document.createElementNS(NS,'rect');
    r.setAttribute('x', s(x)); r.setAttribute('y', s(y));
    r.setAttribute('width', s(w)); r.setAttribute('height', s(h));
    r.setAttribute('fill','#fff'); r.setAttribute('stroke','#000'); r.setAttribute('stroke-width', s(2));
    r.setAttribute('vector-effect','non-scaling-stroke');
    return r;
  };
  const circle = (cx,cy,r)=>{
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('cx', s(cx)); c.setAttribute('cy', s(cy)); c.setAttribute('r', s(r));
    c.setAttribute('fill','#fff'); c.setAttribute('stroke','#000'); c.setAttribute('stroke-width', s(2));
    c.setAttribute('vector-effect','non-scaling-stroke');
    return c;
  };

  // Hus
  const hus = rect(HUS_X, HUS_Y, HUS_W, HUS_H);

  const yMid   = HUS_Y + HUS_H/2;
  const xMid   = HUS_X + HUS_W/2;

  // === Port points: A (left), B (right), OUT (top) ===
  const LEFT_PORT_X  = HUS_X - 20;           // portcentrum till vänster
  const RIGHT_PORT_X = HUS_X + HUS_W + 20;   // portcentrum till höger
  const TOP_PORT_Y   = HUS_Y - 20;           // portcentrum ovanför hus

  const A   = { cx: LEFT_PORT_X,  cy: yMid };
  const B   = { cx: RIGHT_PORT_X, cy: yMid };
  const OUT = { cx: xMid,         cy: TOP_PORT_Y };

  // Inre anslutningslinjer mot huset
  const aLine = line(HUS_X,        A.cy,   A.cx+6, A.cy);
  const bLine = line(HUS_X+HUS_W,  B.cy,   B.cx-6, B.cy);
  const outLn = line(OUT.cx,       OUT.cy+6, OUT.cx, HUS_Y);

  // === OR-shuttle geometri inuti huset ===
  // Horisontell kanal genom mitten
  const leftSeatX  = HUS_X + 16;
  const rightSeatX = HUS_X + HUS_W - 16;

  const midChLeft  = line(HUS_X, yMid, leftSeatX, yMid);
  const midChRight = line(rightSeatX, yMid, HUS_X+HUS_W, yMid);

  // Left seat (angled closure toward center)
  const lSeat1 = line(leftSeatX, yMid, leftSeatX+15, yMid-12);
  const lSeat2 = line(leftSeatX, yMid, leftSeatX+15, yMid+12);

  // Right seat (angled closure toward center)
  const rSeat1 = line(rightSeatX, yMid, rightSeatX-15, yMid-12);
  const rSeat2 = line(rightSeatX, yMid, rightSeatX-15, yMid+12);

  // Shuttle ball in the middle (offset to the left to indicate position)
  const shuttle = circle(xMid-19, yMid, 8);

  // Vertical channel from center up to OUT + small center link
  const stem  = line(xMid, yMid, xMid, HUS_Y);
  const stem2 = line(rightSeatX, yMid, leftSeatX+23, yMid);

  g.append(
    hus,
    midChLeft, midChRight,
    lSeat1, lSeat2, rSeat1, rSeat2,
    shuttle, stem, stem2,
    aLine, bLine, outLn
  );

  // Ports (clickable) with smart text placement
  function makePort(key, p, side){ // side: 'L' | 'R' | 'T'
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port'); c.setAttribute('r', s(6));
    c.setAttribute('cx', s(p.cx)); c.setAttribute('cy', s(p.cy));
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });

    const t = document.createElementNS(NS,'text');
    if (side==='L'){
      t.setAttribute('x', s(p.cx - 14)); t.setAttribute('y', s(p.cy + 4));
      t.setAttribute('text-anchor','end');
    } else if (side==='R'){
      t.setAttribute('x', s(p.cx + 14)); t.setAttribute('y', s(p.cy + 4));
      t.setAttribute('text-anchor','start');
    } else { // T (top) – flytta OUT-texten lite åt höger
      t.setAttribute('x', s(p.cx + 12));
      t.setAttribute('y', s(p.cy - 10));
      t.setAttribute('text-anchor','start');
    }
    t.setAttribute('font-size', Math.max(9, 11*SCALE_orValve));
    t.textContent = key;

    return { c, t };
  }

  const a   = makePort('A',   A,   'L');
  const b   = makePort('B',   B,   'R');
  const out = makePort('OUT', OUT, 'T');
  g.append(a.c, a.t, b.c, b.t, out.c, out.t);

  // Montera
  svg.appendChild(g);
  el.append(svg);
  compLayer.appendChild(el);

  // Komponent-API
  const comp = {
    id, type:'orValve', el, x, y,
    svgW: s(SVG_W), svgH: s(SVG_H),
    gx: s(GX), gy: s(GY),
    ports: {
      OUT:{ cx: s(OUT.cx), cy: s(OUT.cy), el: out.c },
      A:  { cx: s(A.cx),   cy: s(A.cy),   el: a.c },
      B:  { cx: s(B.cx),   cy: s(B.cy),   el: b.c }
    }
  };

  makeDraggable(comp);
  components.push(comp);
  redrawConnections();
  return comp;
}

// js/pushButton32.js
// Push-button 3/2 (momentary): the whole valve (frame, inner boxes, vertical actuator rod, spring)
// is shifted while activated; ports remain fixed.
//
// Left (ACTIVE): 2→1, 3 blocked
// Right  (REST):   2→3, 1 blocked
//
// Signature (matches main.js):
// addPushButton32(x,y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid)

function addPushButton32(
  x, y,
  compLayer, components,
  handlePortClick, makeDraggable, redrawConnections,
  uid
){
  const id = uid();

  // Geometry
  const W = 140, H = 60;
  const NS = 'http://www.w3.org/2000/svg';
  const midX = W / 2;

  // Port positions (only in the right cell; outside the frame for easier wiring)
  const insetRight = Math.round((W - midX) * 0.25); // ~¼ in i högra halvan
  const P2 = { cx: midX + insetRight, cy: -10  };   // 2 (uppe)
  const P1 = { cx: midX + insetRight, cy: H + 10 }; // 1 (nere)
  const P3 = { cx: W - 12,            cy: H + 10 }; // 3 (nere höger)

  // Corresponding positions in the left cell (for inner graphics)
  const L2 = { cx: insetRight, cy: P2.cy };
  const L1 = { cx: insetRight, cy: P1.cy };
  const L3 = { cx: midX - 12,  cy: P3.cy };

  // Root
  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = '';
  el.appendChild(label);

  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  W);
  svg.setAttribute('height', H);
  svg.style.overflow = 'visible';

  // defs: pilspets
  const defs = document.createElementNS(NS,'defs');
  const marker = document.createElementNS(NS,'marker');
  marker.setAttribute('id','arrow');
  marker.setAttribute('markerWidth','10');
  marker.setAttribute('markerHeight','10');
  marker.setAttribute('refX','9');
  marker.setAttribute('refY','5');
  marker.setAttribute('orient','auto');
  const mpath = document.createElementNS(NS,'path');
  mpath.setAttribute('d','M 0 0 L 10 5 L 0 10 z');
  mpath.setAttribute('fill','#000');
  marker.appendChild(mpath);
  defs.append(marker);
  svg.appendChild(defs);

  // === MOVER (ALLT som ska skuffas: ram, lådor, aktiveringsstreck, fjäder) ===
  const mover = document.createElementNS(NS,'g');

  // Ram/ytterbox
  const body = document.createElementNS(NS,'rect');
  body.setAttribute('x',0); body.setAttribute('y',0);
  body.setAttribute('width',W); body.setAttribute('height',H);
  body.setAttribute('fill','#fff'); body.setAttribute('stroke','#000');
  body.setAttribute('stroke-width','2');

  // Hjälpare för ritning
  const path = (d, opts={})=>{
    const p = document.createElementNS(NS,'path');
    p.setAttribute('d', d);
    p.setAttribute('fill', 'none');
    p.setAttribute('stroke', opts.stroke || '#000');
    p.setAttribute('stroke-width', opts.sw || 2);
    if (opts.arrow === 'end')   p.setAttribute('marker-end','url(#arrow)');
    if (opts.arrow === 'start') p.setAttribute('marker-start','url(#arrow)');
    return p;
  };
  const tBlock = (xCenter, yBar, yStemEnd)=>{
    const frag = document.createDocumentFragment();
    frag.appendChild(path(`M ${xCenter-10} ${yBar} L ${xCenter+10} ${yBar}`));
    frag.appendChild(path(`M ${xCenter} ${yBar} L ${xCenter} ${yStemEnd}`));
    return frag;
  };

  // Inre två "lådor"
  const boxLeft  = document.createElementNS(NS,'rect');
  boxLeft.setAttribute('x', 0); boxLeft.setAttribute('y', 0);
  boxLeft.setAttribute('width', midX); boxLeft.setAttribute('height', H);
  boxLeft.setAttribute('fill','#fff'); boxLeft.setAttribute('stroke','#000');
  boxLeft.setAttribute('stroke-width','1.6');

  const boxRight = document.createElementNS(NS,'rect');
  boxRight.setAttribute('x', midX); boxRight.setAttribute('y', 0);
  boxRight.setAttribute('width', midX); boxRight.setAttribute('height', H);
  boxRight.setAttribute('fill','#fff'); boxRight.setAttribute('stroke','#000');
  boxRight.setAttribute('stroke-width','1.6');

  // Vänster cell (AKTIV): 2→1, 3 block (T)  — pilspets vid 1
  const gLeft = document.createElementNS(NS,'g');
  gLeft.appendChild(path(`M ${L1.cx} ${L1.cy - 10} L ${L2.cx} ${L2.cy + 10}`, { arrow:'end' }));
  gLeft.appendChild(tBlock(L3.cx, H-18, L3.cy - 8));

  // Höger cell (VILA): 2→3, 1 block (T)    — pilspets vid 3
  const gRight = document.createElementNS(NS,'g');
  gRight.appendChild(path(`M ${P2.cx} ${P2.cy + 10} L ${P3.cx} ${P3.cy - 10}`, { arrow:'end' }));
  gRight.appendChild(tBlock(P1.cx, H-18, P1.cy - 8));

  // Actuator rod (replaces roller) — moves with the valve
  const actuator = document.createElementNS(NS,'line');
  actuator.setAttribute('x1', -20); actuator.setAttribute('y1', 10);
  actuator.setAttribute('x2', -20); actuator.setAttribute('y2', H-10);
  actuator.setAttribute('stroke', '#000'); actuator.setAttribute('stroke-width', '2');

  // NEW: two horizontal strokes from the actuator rod into the box
  const forkTop = path(`M -20 20 L 0 20`);
  const forkBot = path(`M -20 ${H-20} L 0 ${H-20}`);

  // Spring (right) — moves with the valve
  const spring = document.createElementNS(NS,'g');
  spring.setAttribute('transform', `translate(${W}, ${H/2})`);
  spring.append(
    path(`M 0 0 L 20 0`),
    path(`M 20 0 l 10 -10 l 10 20 l 10 -20 l 10 20`)
  );

  mover.append(body, boxLeft, boxRight, gLeft, gRight, forkTop, forkBot, actuator, spring);
  svg.appendChild(mover);

  // === PORTER (statiska; lämnas kvar) ======================================
  const makePort = (pos, key)=>{
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port');
    c.setAttribute('r', 6);
    c.setAttribute('cx', pos.cx);
    c.setAttribute('cy', pos.cy);
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });
    return c;
  };
  const port2El = makePort(P2, '2');
  const port1El = makePort(P1, '1');
  const port3El = makePort(P3, '3');
  svg.append(port2El, port1El, port3El);

  // === State / interaction (momentary) ==================================
  let isActive = false;

  function applyTransforms(active){
    const dx = active ? midX : 0;  // aktiv ⇒ vänster ruta under porterna
    mover.setAttribute('transform', `translate(${dx}, 0)`);
  }

  function setActive(a){
    if (isActive === a) return;
    isActive = a;
    comp.state.active = a;
    applyTransforms(a);
    redrawConnections();
  }

  // Activate when pressed in the left half; releasing resets
  function isInLeftHalf(evt){
    const rect = svg.getBoundingClientRect();
    const x = (evt.touches?.[0]?.clientX ?? evt.clientX) - rect.left;
    return x < midX;
  }
  svg.addEventListener('mousedown', (e)=>{ if (isInLeftHalf(e)) setActive(true); });
  window.addEventListener('mouseup',   ()=> setActive(false));
  svg.addEventListener('mouseleave',   ()=> setActive(false));
  // Touch
  svg.addEventListener('touchstart', (e)=>{ if (isInLeftHalf(e)) setActive(true); }, {passive:true});
  window.addEventListener('touchend', ()=> setActive(false), {passive:true});
  window.addEventListener('touchcancel', ()=> setActive(false), {passive:true});

  // === Komponent-obj =======================================================
  const comp = {
    id, type: 'push32',
    el, x, y,
    svgW: W, svgH: H, gx: 0, gy: 0,
    ports: {
      '1': { cx: P1.cx, cy: P1.cy, el: port1El },
      '2': { cx: P2.cx, cy: P2.cy, el: port2El },
      '3': { cx: P3.cx, cy: P3.cy, el: port3El }
    },
    state: { active: false },
    recompute(){ applyTransforms(isActive); }
  };

  // Mount
  el.appendChild(svg);
  compLayer.appendChild(el);
  comp.x = x; comp.y = y;
  el.style.left = `${x}px`; el.style.top  = `${y}px`;

  makeDraggable(comp);
  components.push(comp);

  // Init
  applyTransforms(false);
  return comp;
}

// js/restrictor.js
// Restrictor: IN bottom, OUT top. Passes flow but with a delay (tau).
// Scale for ALL restrictors:
const SCALE_restrictor = 0.5;

function addRestrictor(
  x, y,
  compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid
){
  const id = uid();
  const s = (n)=> n * SCALE_restrictor;

  // visual symbol: small rectangle with a narrowing
  const SVG_W=120, SVG_H=140, GX=10, GY=20;

  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = 'Restrictor';

  const NS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  s(SVG_W));
  svg.setAttribute('height', s(SVG_H));

  const g = document.createElementNS(NS,'g');
  g.setAttribute('transform', `translate(${s(GX)},${s(GY)})`);

  const HUS_X=30, HUS_Y=50, HUS_W=60, HUS_H=60;
  const hus = document.createElementNS(NS,'rect');
  hus.setAttribute('x', s(HUS_X));
  hus.setAttribute('y', s(HUS_Y));
  hus.setAttribute('width', s(HUS_W));
  hus.setAttribute('height', s(HUS_H));
  hus.setAttribute('fill','#fff'); hus.setAttribute('stroke','#000');
  hus.setAttribute('stroke-width', s(2));

  // “Smalning” – två trianglar mot en liten hals
  const path = document.createElementNS(NS,'path');
  const x1 = HUS_X+6, x2 = HUS_X+HUS_W-6, yC = HUS_Y+HUS_H/2;
  path.setAttribute('d', `
    M ${s(x1)} ${s(yC+8)} L ${s(x1+16)} ${s(yC)} L ${s(x1)} ${s(yC-8)}
    M ${s(x2)} ${s(yC+8)} L ${s(x2-16)} ${s(yC)} L ${s(x2)} ${s(yC-8)}
  `);
  path.setAttribute('stroke', '#000'); path.setAttribute('fill','none'); path.setAttribute('stroke-width', s(2));

  // Ports: IN bottom, OUT top
  const IN  = { cx: HUS_X + HUS_W/2, cy: HUS_Y + HUS_H + 18 };
  const OUT = { cx: HUS_X + HUS_W/2, cy: HUS_Y - 18 };

  const line = (x1,y1,x2,y2)=>{
    const l = document.createElementNS(NS,'line');
    l.setAttribute('x1', s(x1)); l.setAttribute('y1', s(y1));
    l.setAttribute('x2', s(x2)); l.setAttribute('y2', s(y2));
    l.setAttribute('stroke','#000'); l.setAttribute('stroke-width', s(2));
    return l;
  };
  const inLine  = line(IN.cx,  HUS_Y+HUS_H, IN.cx,  IN.cy-6);
  const outLine = line(OUT.cx, OUT.cy+6,   OUT.cx, HUS_Y);

  function makePort(key, p, labelBelow=false){
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port'); c.setAttribute('r', s(6));
    c.setAttribute('cx', s(p.cx)); c.setAttribute('cy', s(p.cy));
    c.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, key, c); });
    const t = document.createElementNS(NS,'text');
    t.setAttribute('x', s(p.cx));
    t.setAttribute('y', s(labelBelow ? p.cy+18 : p.cy-10));
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-size', Math.max(9, 11*SCALE_restrictor));
    t.textContent = key;
    return { c, t };
  }
  const inp = makePort('IN',  IN,  true);
  const out = makePort('OUT', OUT, false);

  g.append(hus, path, inLine, outLine, inp.c, inp.t, out.c, out.t);
  svg.appendChild(g);
  el.append(label, svg);
  compLayer.appendChild(el);

  const comp = {
    id, type:'restrictor', el, x, y,
    svgW: s(SVG_W), svgH: s(SVG_H), gx: s(GX), gy: s(GY),
    ports: {
      IN:  { cx: s(IN.cx),  cy: s(IN.cy),  el: inp.c },
      OUT: { cx: s(OUT.cx), cy: s(OUT.cy), el: out.c }
    },
    // enkel tidskonstant (sekunder) – kan du senare göra inställningsbar
    tau: 0.25,
  // internal state: when IN was pressurized / released
    _inPress: false,
    _timer: 0
  };

  makeDraggable(comp);
  components.push(comp);
  redrawConnections();
  return comp;
}

// js/source.js
// Pressure source — simple symbol with an OUT port on the top.
// Global skala:
const SCALE_source = 1;

function addSource(x, y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid){
  const id = uid();
  const s = (n)=> n * SCALE_source;

  const SVG_W=120, SVG_H=140, GX=10, GY=20;

  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = '';

  const NS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  s(SVG_W));
  svg.setAttribute('height', s(SVG_H));

  const g = document.createElementNS(NS,'g');
  g.setAttribute('transform', `translate(${s(GX)},${s(GY)})`);

  // Symbol: cirkel (källa) + utgång uppåt
  const Cx = 50, Cy = 50, R = 15;

  const circle = document.createElementNS(NS,'circle');
  circle.setAttribute('cx', s(Cx));
  circle.setAttribute('cy', s(Cy));
  circle.setAttribute('r',  s(R));
  circle.setAttribute('fill','#fff'); circle.setAttribute('stroke','#000'); circle.setAttribute('stroke-width', s(2));

  // NYTT: inre cirkel (tunn ring) inne i källans huvudcirkel
  const innerR = R * 0.55; // justerbar relativ storlek
  const innerCircle = document.createElementNS(NS,'circle');
  innerCircle.setAttribute('cx', s(Cx));
  innerCircle.setAttribute('cy', s(Cy));
  innerCircle.setAttribute('r',  s(innerR));
  innerCircle.setAttribute('fill','none');
  innerCircle.setAttribute('stroke','#000');
  innerCircle.setAttribute('stroke-width', s(2));

  const stem = document.createElementNS(NS,'line');
  stem.setAttribute('x1', s(Cx)); stem.setAttribute('y1', s(Cy - R));
  stem.setAttribute('x2', s(Cx)); stem.setAttribute('y2', s(20));
  stem.setAttribute('stroke','#000'); stem.setAttribute('stroke-width', s(2));

  // Port OUT (uppe)
  const OUT = { cx: Cx, cy: 14 };
  const p = document.createElementNS(NS,'circle');
  p.setAttribute('class','port'); p.setAttribute('r', s(6));
  p.setAttribute('cx', s(OUT.cx)); p.setAttribute('cy', s(OUT.cy));
  p.addEventListener('click', (e)=>{ e.stopPropagation(); handlePortClick(comp, 'OUT', p); });

  const t = document.createElementNS(NS,'text');
  t.setAttribute('x', s(OUT.cx)); t.setAttribute('y', s(OUT.cy - 10));
  t.setAttribute('text-anchor','middle'); t.setAttribute('font-size', Math.max(9, 11*SCALE_source));
  t.textContent = '';

  // Lägg till i ordning så innercirkeln hamnar ovanpå huvudcirkeln
  g.append(circle, innerCircle, stem, p, t);

  svg.appendChild(g);
  el.append(label, svg);
  compLayer.appendChild(el);

  const comp = {
    id, type:'source', el, x, y,
    svgW: s(SVG_W), svgH: s(SVG_H), gx: s(GX), gy: s(GY),
    ports: {
      OUT:{ cx: s(OUT.cx), cy: s(OUT.cy), el: p },
      // för bakåtkompabilitet (vissa projekt kan ha 'P'):
      P:  { cx: s(OUT.cx), cy: s(OUT.cy), el: p }
    }
  };

  makeDraggable(comp);
  components.push(comp);
  redrawConnections();
  return comp;
}

// js/valve52.js — lightweight, pushButton-like structure
// Fixed ports 1/2/3/4/5; boxes/arrows + pilot triangles AND pilot ports (12/14) slide together.
// Pilot 12 (right) and 14 (left) have inward-pointing triangles and:
//  - a short line from triangle tip to the housing wall, and
//  - a horizontal link line from the pilot PORT to the triangle's wall line (x=0 or x=BODY_W).
// Starts in state=1 (right image), i.e. inner content shifted by -W.

function addValve52(
  x, y,
  compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid
){
  const id = uid();

  // ======= Geometry (scalable) =======
  const scale   = 1;
  const W0      = 80;   // single cell width
  const H0      = 60;   // single cell height
  const CELLS   = 2;    // 2 cells for a 5/2 valve

  // SVG offset inside the component DOM (kept for wiring compatibility)
  const gx0     = 115;
  const gy0     = 0;

  const W       = W0 * scale;               // scaled cell width
  const H       = H0 * scale;               // scaled cell height
  const BODY_W  = W * CELLS;                // housing total width (2 cells)
  const BODY_H  = H;
  const SVG_W   = BODY_W + 110 * scale;     // extra for labels/triangles
  const SVG_H   = BODY_H;

  const STROKE  = 2 * scale;
  const FONT    = 10 * scale;
  const PORT_R  = 6 * scale;

  // Pilot triangle dimensions
  const TRI_H   = BODY_H / 4;               // ≈ 1/3 of housing height
  const TRI_W   = TRI_H * 1.2;
  const TRI_GAP = 7;                // gap from housing wall to triangle tip

  // How far pilot ports sit away from the housing (positive = farther from housing)
  const PILOT_PORT_OFFSET = 24 * scale;     // tweak to move ports 12/14 farther/closer

  // ======= Fixed port locations (relative to gRoot local coords; WITHOUT gx/gy) =======
  // 4,2 at top; 5,1,3 at bottom
  const portsFixed = {
    "4": { cx: 10*scale,          cy: -10*scale },
    "2": { cx: (W0-10)*scale,     cy: -10*scale },
    "5": { cx: 10*scale,          cy: (H0+10)*scale },
    "1": { cx: (W0/2)*scale,      cy: (H0+10)*scale },
    "3": { cx: (W0-10)*scale,     cy: (H0+10)*scale }
  };

  // Pilot triangle wall anchors (in gInner local coords; slide with state)
  // Left wall at x=0; right wall at x=BODY_W
  const pilotCY   = (H0/2)*scale;
  const triBase14 = { wallX: 0,       cy: pilotCY };       // left wall line x
  const triBase12 = { wallX: BODY_W,  cy: pilotCY };       // right wall line x

  // Pilot PORT centers (further from housing; in gInner local coords initially)
  const port14LocalX = (-15*scale - PILOT_PORT_OFFSET);             // left side (negative is left)
  const port12LocalX = (W0*2 + 15)*scale + PILOT_PORT_OFFSET;       // right side (positive is right)

  // ======= Wrapper =======
  const el = document.createElement('div');
  el.className = 'comp';
  el.dataset.compId = id;
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = '';

  const NS  = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(NS, 'svg');
  svg.classList.add('compSvg');
  svg.setAttribute('width',  String(SVG_W));
  svg.setAttribute('height', String(SVG_H));
  svg.style.overflow = 'visible';

  // ======= Defs: double-headed arrow marker =======
  const defs = document.createElementNS(NS,'defs');
  const m = document.createElementNS(NS,'marker');
  m.setAttribute('id','arr');
  m.setAttribute('viewBox','0 0 10 10');
  m.setAttribute('refX','10');
  m.setAttribute('refY','5');
  m.setAttribute('markerWidth',  String(6*scale));
  m.setAttribute('markerHeight', String(6*scale));
  m.setAttribute('orient','auto-start-reverse');
  const mp = document.createElementNS(NS,'path');
  mp.setAttribute('d','M 0 0 L 10 5 L 0 10 z');
  mp.setAttribute('fill','#000');
  m.appendChild(mp);
  defs.appendChild(m);
  svg.appendChild(defs);

  // ======= Layers: gRoot (fixed), gInner (slides) =======
  const gRoot  = document.createElementNS(NS,'g');
  gRoot.setAttribute('transform', `translate(${gx0*scale},${gy0*scale})`);

  // Single moving group (pushButton-like)
  const gInner = document.createElementNS(NS,'g');
  gInner.classList.add('inner'); // CSS tip: .comp .inner { transition: transform 160ms ease-in-out; }

  // ======= Slide content (boxes + arrows) — slides with state =======
  const gSlide = document.createElementNS(NS,'g');

  // helper: double-headed arrow
  function addDoubleArrow(parent, x1,y1, x2,y2){
    const line = document.createElementNS(NS,'line');
    line.setAttribute('x1', String(x1));
    line.setAttribute('y1', String(y1));
    line.setAttribute('x2', String(x2));
    line.setAttribute('y2', String(y2));
    line.setAttribute('stroke','#000');
    line.setAttribute('stroke-width', String(STROKE));
    line.setAttribute('marker-start','url(#arr)');
    line.setAttribute('marker-end','url(#arr)');
    parent.appendChild(line);
  }

  // Cell 0 (left image)
  const cell0 = document.createElementNS(NS,'g');
  const r0 = document.createElementNS(NS,'rect');
  r0.setAttribute('x','0'); r0.setAttribute('y','0');
  r0.setAttribute('width',  String(W));
  r0.setAttribute('height', String(H));
  r0.setAttribute('fill','#fff');
  r0.setAttribute('stroke','#000');
  r0.setAttribute('stroke-width', String(STROKE));
  cell0.appendChild(r0);
  addDoubleArrow(cell0, (W0/2)*scale, H, 10*scale, 0);
  addDoubleArrow(cell0, (W0-10)*scale, 0, (W0-10)*scale, H);

  // Cell 1 (right image)
  const cell1 = document.createElementNS(NS,'g');
  cell1.setAttribute('transform', `translate(${W},0)`);
  const r1 = document.createElementNS(NS,'rect');
  r1.setAttribute('x','0'); r1.setAttribute('y','0');
  r1.setAttribute('width',  String(W));
  r1.setAttribute('height', String(H));
  r1.setAttribute('fill','#fff');
  r1.setAttribute('stroke','#000');
  r1.setAttribute('stroke-width', String(STROKE));
  cell1.appendChild(r1);
  addDoubleArrow(cell1, (W0/2)*scale, H, (W0-10)*scale, 0);
  addDoubleArrow(cell1, 10*scale, 0, 10*scale, H);

  gSlide.append(cell0, cell1);

  // ======= Pilot geometry (triangles + wall lines + ports + horizontal link lines) in gInner =======
  function addTriangleAndWallLine(parent, side /* 'left'|'right' */, cy){
    const poly = document.createElementNS(NS,'polygon');
    poly.setAttribute('fill','none'); // change to '#000' for filled triangle
    poly.setAttribute('stroke','#000');
    poly.setAttribute('stroke-width', String(STROKE));

    const ln = document.createElementNS(NS,'line'); // triangle tip -> housing wall
    ln.setAttribute('stroke','#000');
    ln.setAttribute('stroke-width', String(STROKE));

    if (side === 'left') {
      // inward arrow →, housing left wall is x=0 in gInner
      const tipX = 0 - TRI_GAP;
      const pts = [
        [tipX,            cy],
        [tipX - TRI_W,    cy - TRI_H/2],
        [tipX - TRI_W,    cy + TRI_H/2]
      ];
      poly.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
      ln.setAttribute('x1', String(tipX));
      ln.setAttribute('y1', String(cy));
      ln.setAttribute('x2', '0');
      ln.setAttribute('y2', String(cy));
      parent.append(poly, ln);
    } else {
      // inward arrow ←, housing right wall is x=BODY_W in gInner
      const tipX = BODY_W + TRI_GAP;
      const pts = [
        [tipX,            cy],
        [tipX + TRI_W,    cy - TRI_H/2],
        [tipX + TRI_W,    cy + TRI_H/2]
      ];
      poly.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
      ln.setAttribute('x1', String(tipX));
      ln.setAttribute('y1', String(cy));
      ln.setAttribute('x2', String(BODY_W));
      ln.setAttribute('y2', String(cy));
      parent.append(poly, ln);
    }
  }

  function makePort(parent, key, cx, cy, clickableEl){
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','port');
    c.setAttribute('r',  String(PORT_R));
    c.setAttribute('cx', String(cx));
    c.setAttribute('cy', String(cy));

    const t = document.createElementNS(NS,'text');
    t.setAttribute('x', String(cx));
    t.setAttribute('y', String(cy - 10*scale));
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-size', String(FONT));
    t.textContent = key;

    const clickable = clickableEl || c;
    clickable.addEventListener('click', e=>{
      e.stopPropagation();
      handlePortClick(comp, key, c);
    });

    parent.append(c, t);
    return c;
  }

  // Pilot groups (move with gInner)
  const gP14 = document.createElementNS(NS,'g'); // left pilot (14)
  const gP12 = document.createElementNS(NS,'g'); // right pilot (12)

  // Triangles + short wall lines
  addTriangleAndWallLine(gP14, 'left',  pilotCY);
  addTriangleAndWallLine(gP12, 'right', pilotCY);

  // Horizontal link lines from PORT -> triangle wall line (strictly horizontal)
  const link14 = document.createElementNS(NS,'line');
  link14.setAttribute('x1', String(port14LocalX + PORT_R)); // from port edge
  link14.setAttribute('y1', String(pilotCY));
  link14.setAttribute('x2', String(-TRI_GAP - TRI_W));                            // to left wall (x=0)
  link14.setAttribute('y2', String(pilotCY));
  link14.setAttribute('stroke','#000');
  link14.setAttribute('stroke-width', String(STROKE));
  gP14.appendChild(link14);

  const link12 = document.createElementNS(NS,'line');
  link12.setAttribute('x1', String(BODY_W+TRI_GAP+TRI_W));                 // from right wall (x=BODY_W)
  link12.setAttribute('y1', String(pilotCY));
  link12.setAttribute('x2', String(port12LocalX - PORT_R)); // to port edge
  link12.setAttribute('y2', String(pilotCY));
  link12.setAttribute('stroke','#000');
  link12.setAttribute('stroke-width', String(STROKE));
  gP12.appendChild(link12);

  // Pilot ports (placed farther away from housing) — still in gInner coords
  const p14El = makePort(gP14, '14', port14LocalX, pilotCY);
  const p12El = makePort(gP12, '12', port12LocalX, pilotCY);

  // ======= Fixed ports (do NOT move with state) =======
  const gFixedPorts = document.createElementNS(NS,'g');
  const fixedPortEls = {};
  for (const key of Object.keys(portsFixed)){
    const p = portsFixed[key];
    fixedPortEls[key] = makePort(gFixedPorts, key, p.cx, p.cy);
  }

  // ======= Assemble layers =======
  gRoot.append(gFixedPorts, gInner);
  gInner.append(gSlide, gP12, gP14);

  svg.appendChild(gRoot);
  el.append(label, svg);
  compLayer.appendChild(el);

  // ======= Component object (small API, pushButton-like) =======
  const comp = {
    id,
    type: 'valve52',
    el, x, y,

    // Expose offsets and SVG size for wiring/snap compatibility
    gx: gx0 * scale,
    gy: gy0 * scale,
    svgW: SVG_W,
    svgH: SVG_H,

    // 0 = left image, 1 = right image
    state: 1,
    // corresponds to state=1 -> shift gInner by -W
    shift: -W,

    // Port coordinates are in gRoot-local coords (WITHOUT gx/gy).
    ports: {
      "4":  { cx: portsFixed["4"].cx,  cy: portsFixed["4"].cy,  el: fixedPortEls["4"]  },
      "2":  { cx: portsFixed["2"].cx,  cy: portsFixed["2"].cy,  el: fixedPortEls["2"]  },
      "5":  { cx: portsFixed["5"].cx,  cy: portsFixed["5"].cy,  el: fixedPortEls["5"]  },
      "1":  { cx: portsFixed["1"].cx,  cy: portsFixed["1"].cy,  el: fixedPortEls["1"]  },
      "3":  { cx: portsFixed["3"].cx,  cy: portsFixed["3"].cy,  el: fixedPortEls["3"]  },

      // Pilot ports: convert from gInner-local to gRoot-local by adding current shift
      "12": { cx: port12LocalX + (-W),  cy: pilotCY,  el: p12El },
      "14": { cx: port14LocalX + (-W),  cy: pilotCY,  el: p14El }
    },

    // Move only the inner content horizontally (single place to manipulate)
    setShift(dx){
      this.shift = dx|0;
      gInner.setAttribute('transform', `translate(${this.shift},0)`);
      // keep 12/14 connection coordinates updated (still in gRoot-local coords)
      this.ports["12"].cx = port12LocalX + this.shift;
      this.ports["14"].cx = port14LocalX + this.shift;
      redrawConnections();
    },

    // Set logical state (0/1) -> map to shift 0 / -W
    setState(s){
      this.state = s ? 1 : 0;
      const dx = (this.state === 0) ? 0 : -W;
      this.setShift(dx);
    },

    toggle(){
      this.setState(1 - this.state);
    },

    // Move the whole component (DOM)
    setPos(nx, ny){
      this.x = nx|0; this.y = ny|0;
      el.style.left = this.x + 'px';
      el.style.top  = this.y + 'px';
      redrawConnections();
    },

    getBounds(){
      return { x: this.x, y: this.y, w: SVG_W, h: SVG_H };
    },

    setSelected(sel){
      if (sel) el.classList.add('selected'); else el.classList.remove('selected');
    }
  };

  // ======= Simple manual toggle (click either box) =======
  r0.addEventListener('click', ()=> comp.toggle());
  r1.addEventListener('click', ()=> comp.toggle());

  // ======= Init =======
  comp.setState(1);     // start at state 1 (right image)

  makeDraggable(comp);
  components.push(comp);
  return comp;
}

// js/main.js
// Pneumatics workspace with orthogonal multi-segment wires, junctions, selection,
// history, and a simple pressure simulation.
//
// This build adds a new component: air-piloted 3/2 valve (airValve32).
// - Its geometry matches the pushButton32 mover-style (ports static; body slides).
// - Pilot port 12 is horizontal (snap/routing), and pilot pressure drives its state.
// - Spring return when pilot pressure goes away.
// UI: Play/Pause (single toggle), Step, Stop & Reset, Toggle Grid.
// All UI text and comments are in English.

/* ---------- DOM layers ---------- */
const compLayer = document.getElementById('compLayer');
const connLayer = document.getElementById('connLayer');

connLayer.style.zIndex = '2';
compLayer.style.zIndex = '1';
connLayer.style.pointerEvents = 'none'; // custom hit-test in this module

/* ---------- App state ---------- */
let components = [];
// connection shape:
// {
//   from:{id,port}, to:{id,port}, pathEl, labelEl,
//   guides:[{type:'H'|'V',pos:number}], handleEls:[],
//   stubStartLen?:number|null, stubEndLen?:number|null
// }
let connections = [];
let nextId = 1;
let pendingPort = null;
let isDirty = false;
let currentProjectName = 'project';

let selectedConnection = null;
let selectedComponent  = null;
let selectedComponents = new Set();

const Modes = { STOP:'stop', PLAY:'play', PAUSE:'pause' };
let simMode = Modes.STOP;

const DEFAULT_VALVE_STATE = 1;
const DEFAULT_CYL_POS     = 0;

/* ---------- Undo/Redo ---------- */
const HISTORY_LIMIT = 50;
let history = [];
let future  = [];
let isRestoring = false;

/* ---------- Grid & Snap ---------- */
let GRID_ENABLED = true;
const GRID_SIZE = 10;
function snap(v, g=GRID_SIZE){ return GRID_ENABLED ? Math.round(v / g) * g : v; }

/* ---------- Utils ---------- */
function uid(){ return nextId++; }
function workspaceBBox(){ return compLayer.getBoundingClientRect(); }
function canEdit(){ return simMode === Modes.STOP; }
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

/* Fine nudge with arrow keys (Shift = x10) */
function nudgeSelectedComponents(dx, dy){
  if (!canEdit()) return;
  if (selectedComponents.size === 0) return;

  const rect = workspaceBBox();
  selectedComponents.forEach(c=>{
    const nx = snap(clamp(c.x + dx, 40, rect.width  - 40));
    const ny = snap(clamp(c.y + dy, 40, rect.height - 40));
    c.x = nx; c.y = ny;
    c.el.style.left = nx + 'px';
    c.el.style.top  = ny + 'px';
  });
  redrawConnections();
}

/* ---------- Signals & cylinder names ---------- */
const signals = {};
function setSignal(key, value) {
  const v = !!value;
  if (signals[key] === v) return;
  signals[key] = v;
  redrawConnections?.();
}
function getSignal(key) { return !!signals[key]; }
let cylinderCount = 0;
function getNextCylinderLetter() {
  const code = 'A'.charCodeAt(0) + cylinderCount;
  cylinderCount += 1;
  return String.fromCharCode(code);
}

/* ---------- Port → global coordinates ---------- */
function portGlobalPosition(comp, portKey){
  const p = comp.ports?.[portKey];
  if (!p) return { x: comp.x, y: comp.y };
  if (comp.svgW && comp.svgH && (comp.gx !== undefined) && (comp.gy !== undefined)){
    const svg0x = comp.x - comp.svgW/2;
    const svg0y = comp.y - comp.svgH/2;
    return { x: svg0x + comp.gx + p.cx, y: svg0y + comp.gy + p.cy };
  }
  return { x: comp.x + p.cx, y: comp.y + p.cy };
}

/* ---------- Wires (orthogonal) ---------- */
const WIRE_STUB = 14;

// Port entry orientation: 12/14 on 5/2 must be horizontal; 12 on airValve32 is horizontal
function getPortEntryOrientation(comp, portKey){
  if (comp?.type === 'valve52'    && (portKey === '12' || portKey === '14')) return 'H';
  if (comp?.type === 'airValve32' && (portKey === '12' || portKey === '14')) return 'H';
  if (comp?.type === 'andValve') return (portKey === 'OUT') ? 'V' : 'H';
  if (comp?.type === 'orValve')  return (portKey === 'OUT') ? 'V' : 'H';
  return 'V';
}
function isValvePilotPort(comp, portKey){
  if (comp?.type === 'valve52'    && (portKey === '12' || portKey === '14')) return true;
  if (comp?.type === 'airValve32' && portKey === '12') return true;   // ⟵ add
  return false;
}

// Make a short endpoint stub from pHere towards pOther along desired axis
function makeEndpointStub(pHere, pOther, orient, len = WIRE_STUB){
  if (orient === 'H'){
    const dir = (pOther.x >= pHere.x) ? 1 : -1;
    return { x: pHere.x + dir*len, y: pHere.y };
  } else {
    const dir = (pOther.y >= pHere.y) ? 1 : -1;
    return { x: pHere.x, y: pHere.y + dir*len };
  }
}

// Simple orthogonal auto route without guides
function routeAuto(x1,y1,x2,y2){
  if (x1 === x2){
    return {
      points: [{x:x1,y:y1},{x:x2,y:y2}],
      label: { x: x1, y: (y1+y2)/2 - 6 }
    };
  }
  const dy = y2 - y1;
  const s  = Math.min(WIRE_STUB, Math.max(0, Math.abs(dy)/2) || WIRE_STUB);
  const yStart = y1 + (dy >= 0 ? s : -s);
  const yEnd   = y2 - (dy >= 0 ? s : -s);
  return {
    points: [
      {x:x1,y:y1},{x:x1,y:yStart},{x:x2,y:yStart},{x:x2,y:yEnd},{x:x2,y:y2}
    ],
    label: { x: (x1+x2)/2, y: yStart - 6 }
  };
}

// Find next guide of type 'H' or 'V' or fallback to target axis
function nextGuidePos(guides, i, type, fallback){
  for (let k=i+1;k<guides.length;k++){
    if (guides[k].type === type) return guides[k].pos;
  }
  return fallback;
}

// Route with user guides (H/V, in order)
function routeWithGuides(x1,y1,x2,y2, guides){
  const pts = [{x:x1,y:y1}];
  let cur = { x:x1, y:y1 };

  for (let i=0;i<guides.length;i++){
    const g = guides[i];
    if (g.type === 'H'){
      pts.push({ x:cur.x, y:g.pos });
      const nx = nextGuidePos(guides, i, 'V', x2);
      pts.push({ x:nx, y:g.pos });
      cur = { x:nx, y:g.pos };
    } else { // 'V'
      pts.push({ x:g.pos, y:cur.y });
      const ny = nextGuidePos(guides, i, 'H', y2);
      pts.push({ x:g.pos, y:ny });
      cur = { x:g.pos, y:ny };
    }
  }

  if (cur.x !== x2) pts.push({ x:x2, y:cur.y });
  if (cur.y !== y2) pts.push({ x:x2, y:y2 });

  const mid = polylineMidpoint(pts);
  return { points: pts, label: { x: mid.x, y: mid.y - 6 } };
}

function polylineMidpoint(pts){
  let tot=0;
  for (let i=0;i<pts.length-1;i++){
    tot += Math.abs(pts[i+1].x - pts[i].x) + Math.abs(pts[i+1].y - pts[i].y);
  }
  let acc=0;
  const half = tot/2;
  for (let i=0;i<pts.length-1;i++){
    const A = pts[i], B = pts[i+1];
    const seg = Math.abs(B.x-A.x) + Math.abs(B.y-A.y);
    if (acc + seg >= half){
      const need = half - acc;
      if (A.x===B.x){
        const y = A.y + Math.sign(B.y-A.y)*need;
        return { x:A.x, y };
      } else {
        const x = A.x + Math.sign(B.x-A.x)*need;
        return { x, y:A.y };
      }
    }
    acc += seg;
  }
  return pts[Math.floor(pts.length/2)] || pts[0];
}

function pathFromPoints(pts){
  let d = `M ${pts[0].x},${pts[0].y}`;
  for (let i=1;i<pts.length;i++){
    d += ` L ${pts[i].x},${pts[i].y}`;
  }
  return d;
}

/* ---------- Pilot stubs helpers ---------- */
function isPilotEndpoint(conn, which){ // 'start' | 'end'
  const end = (which==='start') ? conn.from : conn.to;
  const comp = components.find(c=> c.id === end.id);
  return isValvePilotPort(comp, end.port);
}
function pilotDir(conn, which){ // +1 for 12, -1 for 14
  const end = (which==='start') ? conn.from : conn.to;
  if (end.port === '12') return +1;
  if (end.port === '14') return -1;
  return +1;
}

/* ---------- Geometry incl. stubs and 12/14/12 rules ---------- */
function computeConnectionGeometry(conn){
  const c1 = components.find(c=>c.id===conn.from.id);
  const c2 = components.find(c=>c.id===conn.to.id);
  if(!c1 || !c2) return null;

  const a = portGlobalPosition(c1, conn.from.port);
  const b = portGlobalPosition(c2, conn.to.port);

  const oStart = getPortEntryOrientation(c1, conn.from.port);
  const oEnd   = getPortEntryOrientation(c2, conn.to.port);

  let a0, b0;
  if (isValvePilotPort(c1, conn.from.port)){
    const dir = pilotDir(conn,'start');
    const L = Math.max(6, Number(conn.stubStartLen ?? WIRE_STUB));
    a0 = { x: a.x + dir*L, y: a.y };
  } else {
    a0 = makeEndpointStub(a, b, oStart);
  }
  if (isValvePilotPort(c2, conn.to.port)){
    const dir = pilotDir(conn,'end');
    const L = Math.max(6, Number(conn.stubEndLen ?? WIRE_STUB));
    b0 = { x: b.x + dir*L, y: b.y };
  } else {
    b0 = makeEndpointStub(b, a, oEnd);
  }

  const guides = Array.isArray(conn.guides) ? conn.guides : [];
  const inner = (guides.length>0)
    ? routeWithGuides(a0.x, a0.y, b0.x, b0.y, guides)
    : routeAuto(a0.x, a0.y, b0.x, b0.y);

  const pts = [];
  pts.push({ x:a.x, y:a.y });
  if (a0.x!==a.x || a0.y!==a.y) pts.push(a0);
  const innerPts = inner.points;
  for (let i=1; i<innerPts.length-1; i++) pts.push(innerPts[i]);
  if (b0.x!==b.x || b0.y!==b.y) pts.push(b0);
  pts.push({ x:b.x, y:b.y });

  const mid = polylineMidpoint(pts);
  return { a, b, points: pts, label: { x: mid.x, y: mid.y - 6 } };
}

function redrawConnections(){
  connLayer.setAttribute('width',  compLayer.clientWidth);
  connLayer.setAttribute('height', compLayer.clientHeight);
  connections.forEach(conn=>{
    const geom = computeConnectionGeometry(conn);
    if (!geom) return;
    const d = pathFromPoints(geom.points);
    conn.pathEl.setAttribute('d', d);
    if (conn.labelEl){
      conn.labelEl.setAttribute('x', geom.label.x);
      conn.labelEl.setAttribute('y', geom.label.y);
    }
    refreshHandlesForConnection(conn, /*repositionOnly=*/true);
  });
}

/* ---------- Selection / deletion ---------- */
function applySelectedClasses(){
  components.forEach(c=>{
    c.el.classList.toggle('selected', selectedComponents.has(c));
  });
}
function clearSelectedConnection(){
  if (selectedConnection){
    selectedConnection.pathEl.classList.remove('selected');
    destroyHandlesForConnection(selectedConnection);
    selectedConnection = null;
  }
}
function selectConnection(conn){
  clearSelectedComponent();
  if (selectedConnection && selectedConnection!==conn){
    selectedConnection.pathEl.classList.remove('selected');
    destroyHandlesForConnection(selectedConnection);
  }
  selectedConnection = conn;
  if (selectedConnection){
    selectedConnection.pathEl.classList.add('selected');
    maybeSeedFirstGuide(selectedConnection);
    refreshHandlesForConnection(selectedConnection);
  }
}
function selectComponent(comp, additive=false){
  clearSelectedConnection();
  if (!additive) selectedComponents.clear();
  if (selectedComponents.has(comp) && additive){
    selectedComponents.delete(comp);
  } else {
    selectedComponents.add(comp);
    selectedComponent = comp;
  }
  applySelectedClasses();
}
function clearSelectedComponent(){
  selectedComponents.clear();
  selectedComponent = null;
  applySelectedClasses();
}

/* --- Swallow background click after marquee --- */
let suppressNextBackgroundClick = false;
compLayer.addEventListener('click', (e)=>{
  if (suppressNextBackgroundClick){
    suppressNextBackgroundClick = false;
    return;
  }
  if (e.target === compLayer){
    clearSelectedConnection();
    clearSelectedComponent();
    hideCtxMenu();
  }
});

/* ---------- Delete + arrows (nudge) ---------- */
window.addEventListener('keydown', (e)=>{
  // ESC cancels linking
  if (e.key === 'Escape' && pendingPort){
    const prevComp = components.find(c=>c.id===pendingPort.id);
    if (prevComp) prevComp.ports[pendingPort.port]?.el?.setAttribute('fill','#fff');
    pendingPort = null;
    setHoverPort(null);
    removePreviewPath();
    document.body.style.cursor = '';
    return;
  }

  // Delete
  if ((e.key==='Delete' || e.key==='Backspace') && canEdit()){
    if (selectedConnection){
      removeConnection(selectedConnection);
      selectedConnection = null;
      e.preventDefault();
      pushHistory('Delete wire');
      redrawConnections();
      return;
    }
    if (selectedComponents.size > 0){
      const toDel = [...selectedComponents];
      toDel.forEach(c => deleteComponent(c));
      clearSelectedComponent();
      e.preventDefault();
      pushHistory('Delete components');
      return;
    }
  }
});

let _nudgeActive = false;
window.addEventListener('keydown', (e)=>{
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || (e.target && e.target.isContentEditable)) return;
  if (!canEdit()) return;

  let dx = 0, dy = 0;
  const step = e.shiftKey ? 10 : 1;

  switch(e.key){
    case 'ArrowLeft':  dx = -step; break;
    case 'ArrowRight': dx =  step; break;
    case 'ArrowUp':    dy = -step; break;
    case 'ArrowDown':  dy =  step; break;
    default: return;
  }

  e.preventDefault();
  nudgeSelectedComponents(dx, dy);
  _nudgeActive = true;
});
window.addEventListener('keyup', (e)=>{
  if (!_nudgeActive) return;
  if (e.key==='ArrowLeft' || e.key==='ArrowRight' || e.key==='ArrowUp' || e.key==='Down'){
    pushHistory(selectedComponents.size>1 ? 'Nudge components' : 'Nudge component');
    _nudgeActive = false;
  }
});

/* ---------- Context menu ---------- */
let ctxMenuEl = null;
function hideCtxMenu(){ if (ctxMenuEl){ ctxMenuEl.remove(); ctxMenuEl = null; } }
function showCtxMenu(x, y, { type, payload }){
  hideCtxMenu();
  const m = document.createElement('div');
  m.className = 'ctxmenu';
  m.style.left = x + 'px';
  m.style.top  = y + 'px';

  const addBtn = (txt, fn)=>{
    const b = document.createElement('button');
    b.textContent = txt;
    b.addEventListener('click', ()=>{ fn(); hideCtxMenu(); });
    m.appendChild(b);
  };

  if (type==='wire' && payload?.conn){
    const conn = payload.conn;
    const hit = payload.hit || null;

    if (hit){
      const segIsH = (hit.seg && hit.seg.A && hit.seg.B) ? (hit.seg.A.y === hit.seg.B.y) : false;
      addBtn('➕ Insert segment here', ()=>{
        if (!conn.guides) conn.guides = [];
        if (segIsH) conn.guides.push({ type:'H', pos: hit.y });
        else        conn.guides.push({ type:'V', pos: hit.x });
        refreshHandlesForConnection(conn);
        redrawConnections();
        pushHistory('Add wire segment');
      });
    }

    if (Array.isArray(conn.guides) && conn.guides.length>0){
      addBtn('➖ Remove nearest segment', ()=>{
        const idx = nearestGuideIndex(conn, hit?.x ?? payload.x, hit?.y ?? payload.y);
        if (idx>=0){
          conn.guides.splice(idx,1);
          refreshHandlesForConnection(conn);
          redrawConnections();
          pushHistory('Remove nearest wire segment');
        }
      });
      addBtn('🧹 Clear all segments', ()=>{
        conn.guides = [];
        refreshHandlesForConnection(conn);
        redrawConnections();
        pushHistory('Clear wire segments');
      });
    }
  }

  const delBtn = document.createElement('button');
  delBtn.textContent = canEdit() ? '🗑️ Delete' : '🔒 Editing requires STOP';
  delBtn.disabled = !canEdit();
  delBtn.addEventListener('click', ()=>{
    if (!canEdit()) return;
    if (type==='component' && payload?.comp){
      deleteComponent(payload.comp);
      clearSelectedComponent();
      pushHistory('Delete component');
    } else if (type==='wire' && payload?.conn){
      removeConnection(payload.conn);
      clearSelectedConnection();
      redrawConnections();
      pushHistory('Delete wire');
    }
    hideCtxMenu();
  });

  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = 'Cancel';
  cancelBtn.addEventListener('click', hideCtxMenu);

  m.append(delBtn, cancelBtn);
  document.body.appendChild(m);

  setTimeout(()=>{
    const closer = (ev)=>{ if (!m.contains(ev.target)) hideCtxMenu(); };
    document.addEventListener('click', closer, { once:true });
    document.addEventListener('contextmenu', closer, { once:true });
    window.addEventListener('scroll', hideCtxMenu, { once:true });
    window.addEventListener('resize', hideCtxMenu, { once:true });
  }, 0);

  ctxMenuEl = m;
}

/* ---------- Component deletion ---------- */
function deleteComponent(comp){
  const toRemove = connections.filter(c => c.from.id===comp.id || c.to.id===comp.id);
  toRemove.forEach(c => removeConnection(c));
  components = components.filter(c => c !== comp);
  comp.el.remove();
  hideCtxMenu();
  redrawConnections();
}

/* ---------- Junction component ---------- */
function addJunction(
  x, y,
  compLayer, components,
  handlePortClick, makeDraggable, redrawConnections, uid
){
  const id = uid();
  const NS = 'http://www.w3.org/2000/svg';

  const el = document.createElement('div');
  el.className = 'comp';
  el.style.left = x + 'px';
  el.style.top  = y + 'px';

  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = 'J';

  const svg = document.createElementNS(NS,'svg');
  svg.classList.add('compSvg');
  const SVG_W = 24, SVG_H = 24;
  svg.setAttribute('width',  SVG_W);
  svg.setAttribute('height', SVG_H);

  const g = document.createElementNS(NS,'g');
  const GX = 12, GY = 12;
  g.setAttribute('transform', `translate(${GX},${GY})`);

  const dot = document.createElementNS(NS,'circle');
  dot.setAttribute('cx', 0); dot.setAttribute('cy', 0);
  dot.setAttribute('r', 3);
  dot.setAttribute('fill', '#000');

  const port = document.createElementNS(NS,'circle');
  port.setAttribute('class','port');
  port.setAttribute('r', 6);
  port.setAttribute('cx', 0);
  port.setAttribute('cy', 0);
  port.addEventListener('click', (e)=>{
    e.stopPropagation();
    handlePortClick(comp, 'J', port);
  });

  g.append(dot, port);
  svg.appendChild(g);
  el.append(label, svg);
  compLayer.appendChild(el);

  const comp = {
    id, type:'junction', el, x, y,
    svgW: SVG_W, svgH: SVG_H, gx: GX, gy: GY,
    ports: { J: { cx:0, cy:0, el: port } }
  };

  makeDraggable(comp);
  components.push(comp);
  redrawConnections();
  return comp;
}

/* ---------- Drag (single + group) ---------- */
function makeDraggable(comp){
  let dragging=false, startMouseX=0, startMouseY=0;
  let offsets = null;

  function onDown(e){
    if (!canEdit()) return;
    if (e.target.closest('.port')) return;

    const additive = e.shiftKey || e.ctrlKey || e.metaKey;

    if (!selectedComponents.has(comp)) {
      if (!additive) selectedComponents.clear();
      selectedComponents.add(comp);
      applySelectedClasses();
    }

    dragging = true;
    const rect = workspaceBBox();
    startMouseX = e.clientX - rect.left;
    startMouseY = e.clientY - rect.top;

    const group = (selectedComponents.size > 1);
    if (group){
      offsets = [...selectedComponents].map(c=>({
        comp:c,
        dx:startMouseX - c.x,
        dy:startMouseY - c.y
      }));
    } else {
      offsets = [{ comp, dx:startMouseX - comp.x, dy:startMouseY - comp.y }];
    }

    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp, { once:true });

    e.preventDefault();
    e.stopPropagation();
  }
  function onMove(e){
    if(!dragging) return;
    const rect = workspaceBBox();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    offsets.forEach(o=>{
      const nx = snap(clamp(mx - o.dx, 40, rect.width-40));
      const ny = snap(clamp(my - o.dy, 40, rect.height-40));
      o.comp.x = nx; o.comp.y = ny;
      o.comp.el.style.left = nx + 'px';
      o.comp.el.style.top  = ny + 'px';
    });
    redrawConnections();
  }
  function onUp(){
    dragging=false;
    offsets = null;
    pushHistory(selectedComponents.size>1 ? 'Move components' : 'Move component');
    window.removeEventListener('mousemove', onMove);
  }

  comp.el.addEventListener('mousedown', onDown);

  comp.el.addEventListener('contextmenu', (e)=>{
    e.preventDefault();
    showCtxMenu(e.clientX, e.clientY, { type:'component', payload:{ comp } });
  });
}

/* ---------- Wires ---------- */
function createWirePath(){
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('class','wire');
  path.style.pointerEvents = 'stroke';
  return path;
}
function createWireLabel(){
  const t = document.createElementNS('http://www.w3.org/2000/svg','text');
  t.setAttribute('class','wireLabel');
  t.setAttribute('text-anchor','middle');
  t.setAttribute('font-size','12');
  t.style.pointerEvents = 'none';
  return t;
}

function addConnection(from, to){
  const path = createWirePath();
  const label = createWireLabel(); // Create a label for the wire
  connLayer.appendChild(path);
  connLayer.appendChild(label);

  // Pilot endpoints get adjustable horizontal stubs
  const cFrom = components.find(c=> c.id === from.id);
  const cTo   = components.find(c=> c.id === to.id);
  const startPilot = isValvePilotPort(cFrom, from.port);
  const endPilot   = isValvePilotPort(cTo,   to.port);

  const conn = {
    from, to, pathEl: path, labelEl: label,
    guides: [], handleEls: [],
    stubStartLen: startPilot ? WIRE_STUB : null,
    stubEndLen:   endPilot   ? WIRE_STUB : null
  };
  connections.push(conn);
  return conn;
}
function removeConnection(conn){
  destroyHandlesForConnection(conn);
  conn.pathEl?.remove();
  conn.labelEl?.remove();
  connections = connections.filter(c=>c!==conn);
}
function finalizeWire(from, to){
  const conn = addConnection(from, to);
  redrawConnections();
  return conn;
}

/* ---------- Port hit-test (magnet) ---------- */
const PORT_SNAP_RADIUS = 16; // px
function findNearestPort(px, py, exclude={ id:null, port:null }){
  let best=null, bestD=Infinity;
  components.forEach(c=>{
    if (!c.ports) return;
    for (const key of Object.keys(c.ports)){
      if (exclude && exclude.id===c.id && exclude.port===key) continue;
      const gp = portGlobalPosition(c, key);
      const d = Math.hypot(gp.x - px, gp.y - py);
      if (d < bestD){ best = { comp:c, key, x:gp.x, y:gp.y, d }; bestD = d; }
    }
  });
  return (best && best.d <= PORT_SNAP_RADIUS) ? best : null;
}

let hoverPort = null;
let lastHoverPortEl = null;
function setHoverPort(newHover){
  if (lastHoverPortEl && (!newHover || newHover.comp.ports[newHover.key].el !== lastHoverPortEl)){
    lastHoverPortEl.setAttribute('fill', '#fff');
    lastHoverPortEl = null;
  }
  hoverPort = newHover;
  if (hoverPort){
    const el = hoverPort.comp.ports[hoverPort.key].el;
    el.setAttribute('fill', '#e9f6ff');
    lastHoverPortEl = el;
  }
}

/* ---------- Ghost-wire (preview) ---------- */
let tempPreviewPath = null;
function ensurePreviewPath(){
  if (tempPreviewPath) return tempPreviewPath;
  tempPreviewPath = document.createElementNS('http://www.w3.org/2000/svg','path');
  tempPreviewPath.setAttribute('class','wire preview');
  tempPreviewPath.style.pointerEvents = 'none';
  connLayer.appendChild(tempPreviewPath);
  return tempPreviewPath;
}
function removePreviewPath(){
  tempPreviewPath?.remove();
  tempPreviewPath = null;
}

/* ---------- Wire hit-test ---------- */
function distPointToSegment(px, py, ax, ay, bx, by){
  const abx = bx - ax, aby = by - ay;
  const apx = px - ax, apy = py - ay;
  const ab2 = abx*abx + aby*aby;
  let t = 0;
  if (ab2 > 0) t = Math.max(0, Math.min(1, (apx*abx + apy*aby)/ab2));
  const cx = ax + t*abx, cy = ay + t*aby;
  const dx = px - cx, dy = py - cy;
  const d = Math.hypot(dx, dy);
  return { d, cx, cy };
}
function hitTestWire(px, py, threshold=8){
  let best = null;
  connections.forEach(conn=>{
    const geom = computeConnectionGeometry(conn);
    if (!geom) return;
    const pts = geom.points;
    for (let i=0;i<pts.length-1;i++){
      const A = pts[i], B = pts[i+1];
      const { d, cx, cy } = distPointToSegment(px, py, A.x, A.y, B.x, B.y);
      if (d <= threshold && (!best || d < best.d)){
        best = { conn, d, x: cx, y: cy, seg: { A, B, i } };
      }
    }
  });
  return best;
}

/* ---------- Junction + select wire (capture) ---------- */
window.addEventListener('click', (e)=>{
  if (!canEdit()) return;

  const rect = workspaceBBox();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  // If we are linking and are over a port → finish to that port
  if (pendingPort && hoverPort){
    finalizeWire(pendingPort, { id:hoverPort.comp.id, port:hoverPort.key });

    const prevComp = components.find(c=>c.id===pendingPort.id);
    prevComp?.ports[pendingPort.port]?.el?.setAttribute('fill','#fff');

    setHoverPort(null);
    removePreviewPath();
    pendingPort = null;
    document.body.style.cursor = '';
    pushHistory('Create wire (snap-to-port)');
    redrawConnections();
    e.stopPropagation(); e.preventDefault();
    return;
  }

  // Linking to a wire ⇒ create junction
  if (pendingPort && !(e.target && e.target.classList?.contains('port'))){
    const hit = hitTestWire(px, py, 8);
    if (hit){
      const j = addJunction(hit.x, hit.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);

      // split wire
      removeConnection(hit.conn);
      addConnection(hit.conn.from, { id:j.id, port:'J' });
      addConnection({ id:j.id, port:'J' }, hit.conn.to);

      // connect the pending endpoint to the junction
      addConnection(pendingPort, { id:j.id, port:'J' });

      const prevComp = components.find(c=>c.id===pendingPort.id);
      prevComp?.ports[pendingPort.port]?.el?.setAttribute('fill','#fff');

      setHoverPort(null);
      removePreviewPath();
      pendingPort = null;
      document.body.style.cursor = '';

      redrawConnections();
      pushHistory('Create junction');
      e.stopPropagation(); e.preventDefault();
      return;
    }
    return;
  }

  // Select a wire if not currently linking
  if (!pendingPort){
    const hit = hitTestWire(px, py, 6);
    if (hit){
      selectConnection(hit.conn);
      e.stopPropagation(); e.preventDefault();
    }
  }
}, true);

// Double-click: add a segment (H/V) at cursor
window.addEventListener('dblclick', (e)=>{
  if (!canEdit()) return;

  const rect = workspaceBBox();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  const hit = hitTestWire(px, py, 6);
  if (!hit) return;

  const isH = (hit.seg.A.y === hit.seg.B.y);
  const conn = hit.conn;
  if (!conn.guides) conn.guides = [];
  conn.guides.push(isH ? { type:'H', pos: hit.y } : { type:'V', pos: hit.x });

  selectConnection(conn);
  refreshHandlesForConnection(conn);
  redrawConnections();
  pushHistory('Add wire segment (dblclick)');

  e.stopPropagation(); e.preventDefault();
}, true);

// Context menu on wire
window.addEventListener('contextmenu', (e)=>{
  if (!canEdit()) return;

  const rect = workspaceBBox();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  const hit = hitTestWire(px, py, 6);
  if (hit){
    selectConnection(hit.conn);
    showCtxMenu(e.clientX, e.clientY, { type:'wire', payload:{ conn:hit.conn, hit, x:px, y:py } });
    e.stopPropagation(); e.preventDefault();
  }
}, true);

/* ---------- Magnetic port + ghost-wire while linking ---------- */
window.addEventListener('mousemove', (e)=>{
  if (!pendingPort) return;

  const rect = workspaceBBox();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  const near = findNearestPort(px, py, pendingPort);
  setHoverPort(near);

  const srcComp = components.find(c=>c.id===pendingPort.id);
  if (!srcComp) return;
  const a = portGlobalPosition(srcComp, pendingPort.port);
  const b = near ? { x:near.x, y:near.y } : { x:px, y:py };

  const orientA = getPortEntryOrientation(srcComp, pendingPort.port);
  const stubA = isValvePilotPort(srcComp, pendingPort.port)
    ? { x: a.x + ((pendingPort.port==='12')?+1:-1) * WIRE_STUB, y: a.y }
    : makeEndpointStub(a, b, orientA);

  const inner = routeAuto(stubA.x, stubA.y, b.x, b.y);
  const pts = [a];
  if (stubA.x!==a.x || stubA.y!==a.y) pts.push(stubA);
  pts.push(...inner.points.slice(1));

  ensurePreviewPath().setAttribute('d', pathFromPoints(pts));
}, true);

/* ---------- Marquee (lasso) ---------- */
let marqueeEl = null;
let marqueeActive = false;
let marqueeStart = { x:0, y:0 };
let marqueeAdditive = false;

function startMarquee(x, y, additive){
  if (!canEdit()) return;
  marqueeActive = true;
  marqueeStart = { x, y };
  marqueeAdditive = additive;

  marqueeEl = document.createElement('div');
  marqueeEl.className = 'marquee';
  marqueeEl.style.left = x + 'px';
  marqueeEl.style.top  = y + 'px';
  document.body.appendChild(marqueeEl);
}
function updateMarquee(x, y){
  if (!marqueeActive || !marqueeEl) return;
  const left   = Math.min(marqueeStart.x, x);
  const top    = Math.min(marqueeStart.y, y);
  const right  = Math.max(marqueeStart.x, x);
  const bottom = Math.max(marqueeStart.y, y);
  marqueeEl.style.left = left + 'px';
  marqueeEl.style.top  = top  + 'px';
  marqueeEl.style.width  = (right-left) + 'px';
  marqueeEl.style.height = (bottom-top) + 'px';
}
function endMarquee(x, y){
  if (!marqueeActive) return;
  const left   = Math.min(marqueeStart.x, x);
  const top    = Math.min(marqueeStart.y, y);
  const right  = Math.max(marqueeStart.x, x);
  const bottom = Math.max(marqueeStart.y, y);

  const rect = workspaceBBox();
  const sel = components.filter(c=>{
    const sx = rect.left + c.x;
    const sy = rect.top  + c.y;
    return sx>=left && sx<=right && sy>=top && sy<=bottom;
  });

  if (!marqueeAdditive) selectedComponents.clear();
  sel.forEach(c => selectedComponents.add(c));
  applySelectedClasses();

  marqueeActive = false;
  marqueeAdditive = false;

  suppressNextBackgroundClick = true;

  marqueeEl?.remove();
  marqueeEl = null;
}

compLayer.addEventListener('mousedown', (e)=>{
  if (!canEdit()) return;
  if (e.target.closest('.comp') || e.target.classList?.contains('port')) return;

  const additive = e.shiftKey || e.ctrlKey || e.metaKey;
  startMarquee(e.clientX, e.clientY, additive);
  e.preventDefault();

  const onMove = (ev)=> updateMarquee(ev.clientX, ev.clientY);
  const onUp = (ev)=>{
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('mouseup', onUp, { once:true });
    endMarquee(ev.clientX, ev.clientY);
    ev.stopPropagation();
  };
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp, { once:true });

  e.stopPropagation();
});

/* ---------- Port linking ---------- */
function handlePortClick(comp, portKey, portEl){
  if (!canEdit()) return;
  hideCtxMenu();
  clearSelectedConnection();

  if (!pendingPort){
    pendingPort = { id: comp.id, port: portKey };
    portEl.setAttribute('fill', '#dff1ff');
    document.body.style.cursor = 'crosshair';
    return;
  }
  if (pendingPort.id === comp.id && pendingPort.port === portKey){
    pendingPort = null;
    portEl.setAttribute('fill', '#fff');
    setHoverPort(null);
    removePreviewPath();
    document.body.style.cursor = '';
    return;
  }

  finalizeWire(pendingPort, { id: comp.id, port: portKey });

  const prevComp = components.find(c=>c.id===pendingPort.id);
  if (prevComp) prevComp.ports[pendingPort.port]?.el?.setAttribute('fill','#fff');

  pendingPort = null;
  setHoverPort(null);
  removePreviewPath();
  document.body.style.cursor = '';
  pushHistory('Create wire');
}

/* ---------- PRESSURE OVERLAY ---------- */
const SOURCE_PRESSURE = 6.0;

function computePressureSet(){
  const key = (id,port)=> `${id}:${port}`;

  // 1) graph of wires
  const adj = new Map(); // Adjacency list for the graph
  const addUndirected = (a,b)=>{
    if (!adj.has(a)) adj.set(a, new Set());
    if (!adj.has(b)) adj.set(b, new Set());
    adj.get(a).add(b); adj.get(b).add(a);
  };
  connections.forEach(conn=>{
    addUndirected(key(conn.from.id, conn.from.port), key(conn.to.id, conn.to.port));
  });

  // 2) start from sources
  const start = [];
  components.forEach(c=>{
    if (c.type==='source'){
      if (c.ports?.OUT) start.push(key(c.id,'OUT'));
      if (c.ports?.P)   start.push(key(c.id,'P'));
    }
  });

  // 3) flood through wiring
  const pressurized = new Set(start);
  const q = [...start];
  while(q.length){
    const cur = q.shift();
    const nbrs = adj.get(cur);
    if (!nbrs) continue;
    for (const n of nbrs){
      if (!pressurized.has(n)){ pressurized.add(n); q.push(n); }
    }
  }

  // 4) component logic + re-flood if changed
  let changed = true;
  while (changed){
    changed = false;

    // 5/2: 1 <-> (4 or 2) depending on state
    components.forEach(v=>{
      if (v.type!=='valve52') return;
      const a = (v.state===0) ? '4' : '2';
      const n1 = `${v.id}:1`, na = `${v.id}:${a}`;
      const before = pressurized.size;
      if (pressurized.has(n1)) pressurized.add(na);
      if (pressurized.has(na)) pressurized.add(n1);
      if (pressurized.size !== before) changed = true;
    });

    // AND valve
    components.forEach(av=>{
      if (av.type!=='andValve') return;
      const nA = `${av.id}:A`, nB = `${av.id}:B`, nO = `${av.id}:OUT`;
      const before = pressurized.size;
      if (pressurized.has(nA) && pressurized.has(nB)) pressurized.add(nO);
      if (pressurized.size !== before) changed = true;
    });

    // OR (shuttle)
    components.forEach(ov=>{
      if (ov.type!=='orValve') return;
      const nA = `${ov.id}:A`, nB = `${ov.id}:B`, nO = `${ov.id}:OUT`;
      const before = pressurized.size;
      if (pressurized.has(nA) || pressurized.has(nB)) pressurized.add(nO);
      if (pressurized.size !== before) changed = true;
    });

    // 3/2 limit valve
    components.forEach(lv=>{
      if (lv.type!=='limit32') return;
      const active = !!lv.state?.active;
      const n2 = `${lv.id}:2`;
      const nT = active ? `${lv.id}:1` : `${lv.id}:3`;
      const before = pressurized.size;
      if (pressurized.has(n2)) pressurized.add(nT);
      if (pressurized.has(nT)) pressurized.add(n2);
      if (pressurized.size !== before) changed = true;
    });

    // 3/2 pushbutton (momentary)
    components.forEach(pv=>{
      if (pv.type!=='push32') return;
      const a = pv.state?.active ? '1' : '3';
      const n2 = `${pv.id}:2`, nx = `${pv.id}:${a}`;
      const before = pressurized.size;
      if (pressurized.has(n2)) pressurized.add(nx);
      if (pressurized.has(nx)) pressurized.add(n2);
      if (pressurized.size !== before) changed = true;
    });

    // 3/2 air-piloted (NEW): same mapping as pushbutton, driven by state.active
    components.forEach(av=>{
      if (av.type!=='airValve32') return;
      const a = av.state?.active ? '1' : '3';
      const n2 = `${av.id}:2`, nx = `${av.id}:${a}`;
      const before = pressurized.size;
      if (pressurized.has(n2)) pressurized.add(nx);
      if (pressurized.has(nx)) pressurized.add(n2);
      if (pressurized.size !== before) changed = true;
    });

    if (changed){
      const queue = [...pressurized];
      while(queue.length){
        const cur = queue.shift();
        const nbrs = adj.get(cur);
        if (!nbrs) continue;
        for (const n of nbrs){
          if (!pressurized.has(n)){ pressurized.add(n); queue.push(n); }
        }
      }
    }
  }

  return pressurized;
}

let lastPressure = new Set();
let stepOnceFlag = false;

/* ---------- Simulation ---------- */
function simulate(dt){
  const playing = (simMode === Modes.PLAY) || stepOnceFlag;

  components.forEach(c=>{
    if (typeof c.recompute === 'function') c.recompute();
  });

  if (playing){ // If the simulation is playing
    lastPressure = computePressureSet();
  } else if (simMode === Modes.STOP){
    lastPressure = new Set();
  }

  if (playing){
    // 5/2 pilot edges (12 ⇒ state=1, 14 ⇒ state=0)
    components.forEach(v=>{
      if (v.type!=='valve52') return;
      if (v._pilot12Prev === undefined) v._pilot12Prev = false;
      if (v._pilot14Prev === undefined) v._pilot14Prev = false;

      const p12 = lastPressure.has(`${v.id}:12`);
      const p14 = lastPressure.has(`${v.id}:14`);

      const rising12 = p12 && !v._pilot12Prev;
      const rising14 = p14 && !v._pilot14Prev;

      if (rising12 && v.state !== 1) v.setState(1);
      else if (rising14 && v.state !== 0) v.setState(0);

      v._pilot12Prev = p12;
      v._pilot14Prev = p14;
    });

    // 3/2 air-piloted: pilot 12 ⇒ active (2↔1), else inactive (2↔3)
    components.forEach(v=>{
      if (v.type!=='airValve32') return;
      const p12 = lastPressure.has(`${v.id}:12`);
      const desired = !!p12;
      if (v.state?.active !== desired){
        // Support both setActive and setState alias
        if (typeof v.setActive === 'function') v.setActive(desired);
        else if (typeof v.setState === 'function') v.setState(desired ? 1 : 0);
      }
    });
  }

  // port overlay + title with bar
  components.forEach(c=>{
    if (!c.ports) return;
    for (const k of Object.keys(c.ports)){
      const n = `${c.id}:${k}`;
      const pressed = lastPressure.has(n) && (playing || simMode===Modes.PAUSE);
      c.ports[k].el?.classList.toggle('pressurized', pressed);
      if (simMode!==Modes.STOP) c.ports[k].el?.setAttribute('title', `${k}: ${pressed ? SOURCE_PRESSURE.toFixed(1) : '0.0'} bar`);
      else c.ports[k].el?.removeAttribute('title');
      // determine if this port has any connection
      // Note: some components (e.g. source) may expose the same DOM element under multiple port keys
      // (e.g. OUT and P). To avoid false negatives we compare the actual port element used by
      // connections rather than only the port key.
      const portEl = c.ports[k]?.el;
      const hasConn = connections.some(conn => {
        if (conn.from.id === c.id){ const fromEl = c.ports?.[conn.from.port]?.el; if (fromEl && fromEl === portEl) return true; }
        if (conn.to.id === c.id){ const toEl = c.ports?.[conn.to.port]?.el; if (toEl && toEl === portEl) return true; }
        return false;
      });
      if (pressed && !hasConn){
        c.ports[k].el?.classList.add('unconnected');
      } else {
        c.ports[k].el?.classList.remove('unconnected');
      }
    }
  });

    // cylinder movement
  if (playing){
    components.filter(c=> c.type==='cylDouble' || c.type==='cylinder' || c.type==='cylSingle').forEach(cyl=>{
      const isPress = (id,port)=> lastPressure.has(`${id}:${port}`);

      let target = cyl.pos;

      if (cyl.type === 'cylSingle'){
        // single-acting: behavior depends on mode ('push' extends on A press, 'pull' retracts on A press)
        let aPress = false;
        const aConns = connections.filter(c=> (c.from.id===cyl.id && c.from.port==='A') || (c.to.id===cyl.id && c.to.port==='A'));
        aConns.forEach(conn=>{
          const other = (conn.from.id===cyl.id) ? conn.to : conn.from;
          if (isPress(other.id, other.port)) aPress = true;
        });
        if ((cyl.mode ?? 'push') === 'push') target = aPress ? 1 : 0;
        else target = aPress ? 0 : 1;
      } else {
        // double-acting behavior: Cap vs Rod
        let capPress=false, rodPress=false;
        const capConns = connections.filter(c=> (c.from.id===cyl.id && c.from.port==='Cap') || (c.to.id===cyl.id && c.to.port==='Cap'));
        const rodConns = connections.filter(c=> (c.from.id===cyl.id && c.from.port==='Rod') || (c.to.id===cyl.id && c.to.port==='Rod'));

        capConns.forEach(conn=>{
          const other = (conn.from.id===cyl.id) ? conn.to : conn.from;
          if (isPress(other.id, other.port)) capPress = true;
        });
        rodConns.forEach(conn=>{
          const other = (conn.from.id===cyl.id) ? conn.to : conn.from;
          if (isPress(other.id, other.port)) rodPress = true;
        });

        if (capPress && !rodPress) target = 1;
        else if (!capPress && rodPress) target = 0;
      }

      const speed = 0.8;
      const dir = Math.sign(target - cyl.pos);
      if (dir!==0) cyl.setPos(cyl.pos + dir*speed*dt);
    });
  }

  // wires: active & label
  connections.forEach(conn=>{
    const aKey = `${conn.from.id}:${conn.from.port}`;
    const bKey = `${conn.to.id}:${conn.to.port}`;
    const aPress = lastPressure.has(aKey);
    const bPress = lastPressure.has(bKey);
    const active = (playing || simMode===Modes.PAUSE) && aPress && bPress;
    conn.pathEl?.classList.toggle('active', active);

    if (simMode===Modes.PLAY || simMode===Modes.PAUSE){
      const bar = (aPress || bPress) ? SOURCE_PRESSURE : 0.0;
      if (conn.labelEl) conn.labelEl.textContent = bar.toFixed(1);
    } else {
      if (conn.labelEl) conn.labelEl.textContent = '';
    }
  });

  stepOnceFlag = false;
}

/* ---------- RAF loop ---------- */
let last = performance.now();
function tick(t){
  const dt = Math.min(0.05, (t-last)/1000);
  last = t;
  simulate(dt);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---------- History & persistence ---------- */
function readCylinderLetterFromComp(comp){
  try {
    const txt = comp.el?.querySelector('.label')?.textContent || '';
    const m = txt.match(/Cylinder\s+([A-Za-z])/);
    return m ? m[1].toUpperCase() : null;
  } catch { return null; }
}

function snapshotProject(){
  const comps = components.map(c=>{
    const base = { id:c.id, type:c.type, x:c.x, y:c.y };
  if (c.type==='valve52') return { ...base, state:c.state };
  if (c.type==='airValve32') return { ...base, active: !!(c.state?.active) };
    if (c.type==='cylDouble' || c.type==='cylinder' || c.type==='cylSingle'){
      const letter = readCylinderLetterFromComp(c);
      const out = { ...base, pos:c.pos??0, letter };
      if (c.type==='cylSingle'){
        out.mode = c.mode ?? 'push';
        out.normallyExtended = !!c.normallyExtended;
      }
      return out;
    }
    if (c.type==='push32')  return { ...base, active: !!(c.state?.active) };
    if (c.type==='limit32'){
      const sensor = typeof c.getSensorKey === 'function' ? c.getSensorKey() : null;
      return { ...base, sensor };
    }
    return base; // junction/and/or/source
  });
  const conns = connections.map(conn=>({
    from:{ id:conn.from.id, port:conn.from.port },
    to:  { id:conn.to.id,   port:conn.to.port },
    guides: (Array.isArray(conn.guides) && conn.guides.length>0)
              ? conn.guides.map(g=>({type:g.type,pos:g.pos}))
              : [],
    stubStartLen: (typeof conn.stubStartLen === 'number') ? conn.stubStartLen : null,
    stubEndLen:   (typeof conn.stubEndLen   === 'number') ? conn.stubEndLen   : null
  }));
  return { version: 18, comps, conns };
}
function clearProject(){
  connections.forEach(c=>removeConnection(c));
  connections = [];
  components.forEach(c=>c.el.remove());
  components = [];
  nextId = 1;
  pendingPort = null;

  cylinderCount = 0;                 // restart letter counter
  for (const k of Object.keys(signals)) delete signals[k]; // cleanup old sensors

  clearSelectedConnection();
  clearSelectedComponent();
  hideCtxMenu();
  redrawConnections();
}
async function loadProject(data){
  isRestoring = true;
  clearProject();

  const idMap = new Map();
  let _maxCylIndex = -1;

  for (const sc of data.comps){
    let comp = null;
    if (sc.type === 'source'){
      comp = addSource(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    } else if (sc.type === 'valve52'){
      const v = addValve52(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
      if (typeof sc.state==='number' && typeof v.setState==='function') v.setState(sc.state);
      v._pilot12Prev = false; v._pilot14Prev = false;
      wrapValveToggleGuard(v);
      comp = v;
    } else if (sc.type === 'airValve32'){
      comp = addAirValve32(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
      if (typeof sc.active==='boolean'){
        if (typeof comp.setActive==='function') comp.setActive(sc.active);
        else if (typeof comp.setState==='function') comp.setState(sc.active ? 1 : 0);
      }
    } else if (sc.type === 'cylDouble' || sc.type==='cylinder'){
      const letterProvider = sc.letter ? (()=> sc.letter) : getNextCylinderLetter;
      comp = addCylinderDouble(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid, letterProvider, setSignal);
      if (typeof sc.pos==='number' && typeof comp.setPos==='function') comp.setPos(sc.pos);
      if (sc.letter){
        const idx = sc.letter.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
        if (!Number.isNaN(idx)) _maxCylIndex = Math.max(_maxCylIndex, idx);
      }
    } else if (sc.type === 'cylSingle' || sc.type === 'cylinderSingle'){
      const letterProvider = sc.letter ? (()=> sc.letter) : getNextCylinderLetter;
      // allow storing pos, letter, mode and normallyExtended
      const opts = { normallyExtended: !!sc.normallyExtended, mode: sc.mode };
      comp = addCylinderSingle(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid, letterProvider, setSignal, opts);
      if (typeof sc.pos==='number' && typeof comp.setPos==='function') comp.setPos(sc.pos);
      if (sc.letter){
        const idx = sc.letter.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
        if (!Number.isNaN(idx)) _maxCylIndex = Math.max(_maxCylIndex, idx);
      }
    } else if (sc.type === 'andValve'){
      comp = addAndValve(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    } else if (sc.type === 'orValve'){
      comp = addOrValve(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    } else if (sc.type === 'limit32'){
      const lv = addLimitValve32(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid, getSignal);
      if (typeof sc.sensor === 'string' && sc.sensor.trim()){
        lv.setSensorKey(sc.sensor);
      }
      comp = lv;
    } else if (sc.type === 'push32'){
      comp = addPushButton32(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
      if (typeof sc.active==='boolean'){ comp.state.active = sc.active; comp.recompute?.(); }
    } else if (sc.type === 'junction'){
      comp = addJunction(sc.x, sc.y, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    } else {
      continue;
    }
    idMap.set(sc.id, comp.id);
  }

  // adjust next cylinder letter
  cylinderCount = (_maxCylIndex >= 0) ? (_maxCylIndex + 1) : 0;

  for (const conn of data.conns){
    const newFromId = idMap.get(conn.from.id);
    const newToId   = idMap.get(conn.to.id);
    if (!newFromId || !newToId) continue;
    const c = finalizeWire({ id:newFromId, port:conn.from.port }, { id:newToId, port:conn.to.port });
    if (Array.isArray(conn.guides)){
      c.guides = conn.guides.map(g=>({ type:(g.type==='V'?'V':'H'), pos: Number(g.pos) }));
    } else if (typeof conn.ctrlY === 'number'){ // backward compat
      c.guides = [{ type:'H', pos: conn.ctrlY }];
    }
    if (typeof conn.stubStartLen === 'number') c.stubStartLen = conn.stubStartLen;
    if (typeof conn.stubEndLen   === 'number') c.stubEndLen   = conn.stubEndLen;
  }

  redrawConnections();
  isRestoring = false;
}

/* ---------- History ---------- */
function pushHistory(_label=''){
  if (isRestoring) return;
  const snap = snapshotProject();
  history.push(JSON.stringify(snap));
  if (history.length > HISTORY_LIMIT) history.shift();
  future = [];
  updateUndoRedoButtons();

  const cleanLabels = ['Initial','Load project','Reset'];
  isDirty = !cleanLabels.includes(_label);
}
function undo(){
  if (history.length < 2) return;
  const current = snapshotProject();
  future.push(JSON.stringify(current));
  const prev = JSON.parse(history[history.length-2]);
  history.pop();
  isRestoring = true;
  loadProject(prev).then(()=>{ isRestoring = false; updateUndoRedoButtons(); });
}
function redo(){
  if (future.length === 0) return;
  const next = JSON.parse(future.pop());
  const current = snapshotProject();
  history.push(JSON.stringify(current));
  isRestoring = true;
  loadProject(next).then(()=>{ isRestoring = false; updateUndoRedoButtons(); });
}

/* ---------- UI helpers ---------- */
function ensureButton(id, label, onClick){
  let btn = document.getElementById(id);
  if (!btn){
    const side = document.querySelector('.sidebar') || document.body;
    btn = document.createElement('button');
    btn.id = id; btn.className = 'btn';
    side.appendChild(btn);
  }
  btn.textContent = label;
  const fresh = btn.cloneNode(true);
  btn.replaceWith(fresh);
  fresh.addEventListener('click', onClick);
}

function setMode(m){
  if (m === simMode) return;
  simMode = m;
  updateModeButtons();
  if (simMode !== Modes.PLAY){
    connections.forEach(conn => conn.pathEl.classList.remove('active'));
  }
}

function updateUndoRedoButtons(){
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  if (undoBtn) undoBtn.disabled = !canEdit() || history.length < 2;
  if (redoBtn) redoBtn.disabled = !canEdit() || future.length === 0;
}

/* ---------- Reset system ---------- */
function resetSystem(){
  setMode(Modes.STOP);
  components.forEach(c=>{
    if (c.type==='valve52' && typeof c.setState==='function') c.setState(DEFAULT_VALVE_STATE);
    else if (c.type==='airValve32'){
      if (typeof c.setActive==='function') c.setActive(false);
      else if (typeof c.setState==='function') c.setState(0);
    }
  else if (c.type==='cylSingle' && typeof c.setPos==='function') c.setPos(c.normallyExtended ? 1 : 0);
  else if ((c.type==='cylDouble'||c.type==='cylinder') && typeof c.setPos==='function') c.setPos(DEFAULT_CYL_POS);
    else if (c.type==='push32'){ c.state.active=false; c.recompute?.(); }
    if (c.type==='valve52'){ c._pilot12Prev=false; c._pilot14Prev=false; }
  });
  connections.forEach(conn => conn.pathEl.classList.remove('active'));
  lastPressure = new Set();
  components.forEach(c=>{
    if (!c.ports) return;
    for (const k of Object.keys(c.ports)){
      c.ports[k].el?.classList.remove('pressurized');
      c.ports[k].el?.removeAttribute('title');
    }
  });
  connections.forEach(conn => { if (conn.labelEl) conn.labelEl.textContent=''; });

  clearSelectedConnection(); clearSelectedComponent(); hideCtxMenu();
  pushHistory('Reset');
}

/* ---- Lock manual toggle of 5/2 to PLAY ---- */
function wrapValveToggleGuard(valveComp){
  if (!valveComp || typeof valveComp.toggle!=='function') return;
  const original = valveComp.toggle.bind(valveComp);
  valveComp.toggle = function(){ if (simMode!==Modes.PLAY) return; original(); };
}

/* ---------- Inject CSS overlay ---------- */
(function injectOverlayCSS(){
  if (document.getElementById('overlayCSS')) return;
  const css = `
    /* Workspace grid */
    #compLayer {
      ${GRID_ENABLED ? `background-image:
        linear-gradient(to right, rgba(0,0,0,.06) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(0,0,0,.06) 1px, transparent 1px);
      background-size: ${GRID_SIZE}px ${GRID_SIZE}px;` : ''}
    }

    .wire { stroke:#000; stroke-width:2; fill:none; vector-effect: non-scaling-stroke; }
    .wire.preview { stroke:#888; stroke-dasharray:4 4; }
  /* Active wires (pressurized) use the port color (blue) */
  .wire.active { stroke: var(--port); stroke-dasharray:6 6; animation: wireflow 1.2s linear infinite; }
    @keyframes wireflow { to { stroke-dashoffset: -12; } }
    .wire.selected { stroke:#0a74ff; stroke-width:3; }
    .comp.selected { outline: 2px dashed #0a74ff; outline-offset: 2px; }

  .port { fill:#fff; stroke:#0a74ff; stroke-width:1.5; cursor: crosshair; }
  /* Ports that are pressurized during simulation are highlighted in the port color (blue) */
  .port.pressurized { fill: var(--port); stroke: var(--port); stroke-width:2; }
  /* If a pressurized port is not connected to any other component, blink it red to draw attention */
  .port.pressurized.unconnected { fill: var(--accent); stroke: var(--accent); animation: portBlink 1.8s linear infinite; }
  @keyframes portBlink { 0%,100% { opacity: 1; } 50% { opacity: 0.25; } }

    .wireLabel {
      font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      fill:#222;
      paint-order: stroke;
      stroke: #fff;
      stroke-width: 3px;
      pointer-events: none;
    }

    .ctxmenu {
      position: fixed; z-index: 9999;
      background:#fff; border:1px solid #ccc; border-radius:8px;
      box-shadow: 0 8px 22px rgba(0,0,0,.12);
      padding:6px; font-size:14px; min-width:200px;
    }
    .ctxmenu button {
      display:block; width:100%; text-align:left;
      background:none; border:0; padding:8px 10px; cursor:pointer;
    }
    .ctxmenu button:hover { background:#f5f7ff; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }

    .marquee {
      position: fixed;
      border: 1px dashed #0a74ff;
      background: rgba(10,116,255,0.08);
      pointer-events: none;
      z-index: 9998;
    }

    .ctrlHandle {
      position: absolute;
      width: 12px; height: 12px;
      background: #fff;
      border: 2px solid #0a74ff;
      border-radius: 3px;
      box-shadow: 0 1px 3px rgba(0,0,0,.2);
      z-index: 3;
    }
    .ctrlHandle.h { cursor: ns-resize; }
    .ctrlHandle.v { cursor: ew-resize; }
  `;
  const style = document.createElement('style');
  style.id = 'overlayCSS';
  style.textContent = css;
  document.head.appendChild(style);
})();

/* ---------- Buttons ---------- */
function ensureGridStyle(){
  const style = document.getElementById('overlayCSS');
  if (!style) return;
  const enabled = GRID_ENABLED;
  const repl = style.textContent.replace(
    /#compLayer\s*\{[\s\S]*?\}/,
    `#compLayer { ${enabled ? `
      background-image:
        linear-gradient(to right, rgba(0,0,0,.06) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(0,0,0,.06) 1px, transparent 1px);
      background-size: ${GRID_SIZE}px ${GRID_SIZE}px;` : ''} }`
  );
  style.textContent = repl;
}

function updateModeButtons(){
  ensureButton('btnPlayPause',
    simMode===Modes.PLAY ? '⏸️ Pause' : '▶️ Play',
    ()=>{
      if (simMode===Modes.PLAY){ setMode(Modes.PAUSE); }
      else { setMode(Modes.PLAY); }
    }
  );
  ensureButton('btnStep',  '⏭️ Step', ()=>{
    stepOnceFlag = true;
    simulate(0.02);
  });
  ensureButton('btnStop',  '⏹️ Stop & Reset', ()=> resetSystem());
  ensureButton('btnToggleGrid', GRID_ENABLED ? '🔳 Hide Grid' : '🔲 Show Grid', ()=>{
    GRID_ENABLED = !GRID_ENABLED;
    ensureGridStyle();
  });

  const editableButtons = ['addSource','addValve52','addAir32','addCylDouble','addCylSingle','addAnd','addOr','addLimit32','addPush32','saveProj','loadProj','undoBtn','redoBtn'];
  editableButtons.forEach(id=>{
    const b = document.getElementById(id);
    if (b) b.disabled = !canEdit();
  });

  // Hide per-component single-acting mode buttons while simulation is running
  const shouldShowModeBtns = canEdit(); // only show when STOP/edit mode
  components.forEach(c=>{
    if (c && c.modeBtn && c.modeBtn.style){
      c.modeBtn.style.display = shouldShowModeBtns ? '' : 'none';
    }
  });
}
function addButtons(){
  ensureButton('addSource',  '➕ Pressure source', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    addSource(r.width*0.15, r.height*0.50, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    pushHistory('Add source');
  });
  ensureButton('addValve52', '➕ 5/2 valve', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    const v = addValve52(r.width*0.40, r.height*0.50, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    v._pilot12Prev = false; v._pilot14Prev = false;
    wrapValveToggleGuard(v);
    pushHistory('Add valve52');
  });
  ensureButton('addAir32',   '➕ 3/2 air-piloted', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    addAirValve32(r.width*0.33, r.height*0.35, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    pushHistory('Add airValve32');
  });




  ensureButton('addCylDouble','➕ Cylinder (double-acting)', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    addCylinderDouble(r.width*0.70, r.height*0.50, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid, getNextCylinderLetter, setSignal);
    pushHistory('Add cylinder');
  });
  ensureButton('addCylSingle','➕ Cylinder (single-acting)', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    addCylinderSingle(r.width*0.70, r.height*0.60, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid, getNextCylinderLetter, setSignal);
    pushHistory('Add single cylinder');
  });
  ensureButton('addAnd',     '➕ AND valve', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    addAndValve(r.width*0.25, r.height*0.35, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    pushHistory('Add AND');
  });
  ensureButton('addOr',      '➕ OR valve', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    addOrValve(r.width*0.25, r.height*0.65, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    pushHistory('Add OR');
  });
  ensureButton('addLimit32', '➕ 3/2 limit valve', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    addLimitValve32(r.width*0.52, r.height*0.28, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid, getSignal);
    pushHistory('Add limit32');
  });
  ensureButton('addPush32',  '➕ 3/2 pushbutton', ()=>{
    if (!canEdit()) return;
    const r = workspaceBBox();
    addPushButton32(r.width*0.25, r.height*0.50, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
    pushHistory('Add push32');
  });

  ensureButton('saveProj', '💾 Save project', ()=>{
    if (!canEdit()) return;
    const snap = snapshotProject();
    const defaultName = currentProjectName || 'project';
    const answer = window.prompt('Enter a name for the project (without extension):', defaultName);
    if (answer === null) return;
    let name = (answer.trim() || defaultName).replace(/[\\/:*?"<>|]+/g, '').replace(/\s+/g, '_');
    if (!name) name = 'project';
    currentProjectName = name;
    const filename = /\.json$/i.test(name) ? name : `${name}.json`;
    const a = document.createElement('a');
    a.href = 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(snap, null, 2));
    a.download = filename;
    a.style.display='none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    isDirty = false;
  });

  ensureButton('loadProj', '📂 Load project', ()=>{
    if (!canEdit()) return;
    const inp = document.createElement('input');
    inp.type = 'file'; inp.accept = 'application/json';
    inp.onchange = async (e)=>{
      const file = e.target.files?.[0]; if (!file) return;
      currentProjectName = file.name.replace(/\.json$/i, '');
      try { const data = JSON.parse(await file.text()); await loadProject(data); pushHistory('Load project'); }
      catch(err){ console.error('Load error:', err); alert('Invalid project file.'); }
    };
    inp.click();
  });

  ensureButton('undoBtn', '↩️ Undo', ()=> { if (canEdit()) undo(); });
  ensureButton('redoBtn', '↪️ Redo', ()=> { if (canEdit()) redo(); });

  updateModeButtons();
  updateUndoRedoButtons();
}
addButtons();

/* ---------- Initial layout ---------- */
window.addEventListener('load', ()=>{
  const r = workspaceBBox();
  addSource(r.width*0.15, r.height*0.50, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);

  // ensure wire arrow markers if you want to enable them
  (function ensureWireMarkers(){
    if (connLayer.__markersReady) return;
    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
    const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
    marker.setAttribute('id','arrow');
    marker.setAttribute('markerWidth','8');
    marker.setAttribute('markerHeight','8');
    marker.setAttribute('refX','8');
    marker.setAttribute('refY','4');
    marker.setAttribute('orient','auto-start-reverse');
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d','M0,0 L8,4 L0,8 Z');
    path.setAttribute('fill','#000');
    marker.appendChild(path);
    defs.appendChild(marker);
    connLayer.appendChild(defs);
    connLayer.__markersReady = true;
  })();

  const v = addValve52(r.width*0.40, r.height*0.50, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid);
  v._pilot12Prev = false; v._pilot14Prev = false;
  wrapValveToggleGuard(v);
  addCylinderDouble(r.width*0.70, r.height*0.50, compLayer, components, handlePortClick, makeDraggable, redrawConnections, uid, getNextCylinderLetter, setSignal);
  pushHistory('Initial');
});

// Warn if closing with unsaved changes
window.addEventListener('beforeunload', (e)=>{
  if (!isDirty) return;
  e.preventDefault();
  e.returnValue = '';
});

/* ---------- Segment helpers ---------- */
// function maybeSeedFirstGuide(conn){
//   if (Array.isArray(conn.guides) && conn.guides.length>0) return;
//   const geom = computeConnectionGeometry({ ...conn, guides: [] });
//   if (!geom) return;
//   const { a, b } = geom;
//   if (a.x !== b.x){
//     const y = (a.y + b.y)/2;
//     conn.guides = [{ type:'H', pos:y }];
//   } else {
//     const x = (a.x + b.x)/2;
//     conn.guides = [{ type:'V', pos:x }];
//   }
// }
function nearestGuideIndex(conn, px, py){
  if (!Array.isArray(conn.guides) || conn.guides.length===0) return -1;
  let bestIdx = -1, bestD = Infinity;
  conn.guides.forEach((g, i)=>{
    const d = (g.type==='H') ? Math.abs(py - g.pos) : Math.abs(px - g.pos);
    if (d < bestD){ bestD = d; bestIdx = i; }
  });
  return bestIdx;
}

/* ---------- Handles for segments (incl. pilot stubs) ---------- */
function destroyHandlesForConnection(conn){
  if (Array.isArray(conn.handleEls)){
    conn.handleEls.forEach(el=> el?.remove());
  }
  conn.handleEls = [];
}

function refreshHandlesForConnection(conn, repositionOnly=false){
  // Only when selected
  if (selectedConnection !== conn){
    destroyHandlesForConnection(conn);
    return;
  }

  const geom = computeConnectionGeometry(conn);
  if (!geom) return;
  const { a, b } = geom;

  if (!Array.isArray(conn.guides)) conn.guides = [];

  // Create handles
  if (!repositionOnly){
    destroyHandlesForConnection(conn);

    // --- Guide handles (H/V) ---
    conn.handleEls = conn.guides.map((g, idx)=>{
      const el = document.createElement('div');
      el.className = 'ctrlHandle ' + (g.type==='H' ? 'h' : 'v');
      el.title = g.type==='H' ? 'Drag up/down to move a horizontal segment'
                              : 'Drag left/right to move a vertical segment';
      compLayer.appendChild(el);

      let dragging=false, startOff=0;
      const onDown = (e)=>{
        if (!canEdit()) return;
        dragging = true;
        const rect = workspaceBBox();
        if (g.type==='H'){
          startOff = (e.clientY - rect.top) - g.pos;
          el.style.cursor = 'ns-resize';
        } else {
          startOff = (e.clientX - rect.left) - g.pos;
          el.style.cursor = 'ew-resize';
        }
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp, { once:true });
        e.stopPropagation(); e.preventDefault();
      };
      const onMove = (e)=>{
        if (!dragging) return;
        const rect = workspaceBBox();
        if (g.type==='H'){
          let y = e.clientY - rect.top - startOff;
          y = clamp(y, 20, rect.height-20);
          g.pos = y;
        } else {
          let x = e.clientX - rect.left - startOff;
          x = clamp(x, 20, rect.width-20);
          g.pos = x;
        }
        redrawConnections();
      };
      const onUp = ()=>{
        dragging=false;
        el.style.cursor = '';
        pushHistory('Move wire segment');
        window.removeEventListener('mousemove', onMove);
      };

      el.addEventListener('mousedown', onDown);
      el.addEventListener('contextmenu', (e)=>{
        e.preventDefault();
        const idxNow = conn.guides.indexOf(g);
        if (idxNow>=0){
          conn.guides.splice(idxNow,1);
          refreshHandlesForConnection(conn);
          redrawConnections();
          pushHistory('Remove wire segment');
        }
      });

      return el;
    });

    // --- Pilot stub handle (start) ---
    if (isPilotEndpoint(conn,'start')){
      const el = document.createElement('div');
      el.className = 'ctrlHandle v';
      el.title = 'Drag to change pilot stub length';
      compLayer.appendChild(el);
      conn.handleEls.push(el);

      let dragging=false, baseX=0, baseLen=Number(conn.stubStartLen ?? WIRE_STUB);
      const onDown = (e)=>{
        if (!canEdit()) return;
        dragging = true;
        const c1 = components.find(c=>c.id===conn.from.id);
        const aPort = portGlobalPosition(c1, conn.from.port);
        baseX = aPort.x;
        baseLen = Number(conn.stubStartLen ?? WIRE_STUB);
        const dir0 = pilotDir(conn,'start');
        const move = (ev)=>{
          if (!dragging) return;
          const rect = workspaceBBox();
          const mx = ev.clientX - rect.left;
          const dir = dir0;
          let L = Math.max(6, Math.abs(mx - baseX));
          // enforce outward direction
          if (dir>0 && mx < baseX) L = Math.max(6, baseLen);
          if (dir<0 && mx > baseX) L = Math.max(6, baseLen);
          conn.stubStartLen = L;
          redrawConnections();
        };
        const up = ()=>{
          dragging=false;
          pushHistory('Resize pilot stub (start)');
          window.removeEventListener('mousemove', move);
        };
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', up, { once:true });
        e.stopPropagation(); e.preventDefault();
      };
      el.addEventListener('mousedown', onDown);
    }

    // --- Pilot stub handle (end) ---
    if (isPilotEndpoint(conn,'end')){
      const el = document.createElement('div');
      el.className = 'ctrlHandle v';
      el.title = 'Drag to change pilot stub length';
      compLayer.appendChild(el);
      conn.handleEls.push(el);

      let dragging=false, baseX=0, baseLen=Number(conn.stubEndLen ?? WIRE_STUB);
      const onDown = (e)=>{
        if (!canEdit()) return;
        dragging = true;
        const c2 = components.find(c=>c.id===conn.to.id);
        const bPort = portGlobalPosition(c2, conn.to.port);
        baseX = bPort.x;
        baseLen = Number(conn.stubEndLen ?? WIRE_STUB);
        const dir0 = pilotDir(conn,'end');
        const move = (ev)=>{
          if (!dragging) return;
          const rect = workspaceBBox();
          const mx = ev.clientX - rect.left;
          const dir = dir0;
          let L = Math.max(6, Math.abs(mx - baseX));
          if (dir>0 && mx < baseX) L = Math.max(6, baseLen);
          if (dir<0 && mx > baseX) L = Math.max(6, baseLen);
          conn.stubEndLen = L;
          redrawConnections();
        };
        const up = ()=>{
          dragging=false;
          pushHistory('Resize pilot stub (end)');
          window.removeEventListener('mousemove', move);
        };
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', up, { once:true });
        e.stopPropagation(); e.preventDefault();
      };
      el.addEventListener('mousedown', onDown);
    }
  }

  // Position handles (guides)
  conn.guides.forEach((g, i)=>{
    const el = conn.handleEls[i];
    if (!el) return;
    if (g.type==='H'){
      const xMid = (a.x + b.x)/2;
      el.style.left = (xMid - 6) + 'px';
      el.style.top  = (g.pos - 6) + 'px';
    } else {
      const yMid = (a.y + b.y)/2;
      el.style.left = (g.pos - 6) + 'px';
      el.style.top  = (yMid - 6) + 'px';
    }
  });

  // Position handles (pilot stubs)
  let handleIdx = conn.guides.length;
  if (isPilotEndpoint(conn,'start')){
    const el = conn.handleEls[handleIdx++];
    if (el){
      const c1 = components.find(c=>c.id===conn.from.id);
      const aPort = portGlobalPosition(c1, conn.from.port);
      const dir = pilotDir(conn,'start');
      const L = Number(conn.stubStartLen ?? WIRE_STUB);
      el.style.left = (aPort.x + dir*L - 6) + 'px';
      el.style.top  = (aPort.y - 6) + 'px';
    }
  }
  if (isPilotEndpoint(conn,'end')){
    const el = conn.handleEls[handleIdx];
    if (el){
      const c2 = components.find(c=>c.id===conn.to.id);
      const bPort = portGlobalPosition(c2, conn.to.port);
      const dir = pilotDir(conn,'end');
      const L = Number(conn.stubEndLen ?? WIRE_STUB);
      el.style.left = (bPort.x + dir*L - 6) + 'px';
      el.style.top  = (bPort.y - 6) + 'px';
    }
  }
}

function maybeSeedFirstGuide(conn){
  if (Array.isArray(conn.guides) && conn.guides.length>0) return;
  const geom = computeConnectionGeometry({ ...conn, guides: [] });
  if (!geom) return;
  const { a, b } = geom;
  if (a.x !== b.x){
    const y = (a.y + b.y)/2;
    conn.guides = [{ type:'H', pos:y }];
  } else {
    const x = (a.x + b.x)/2;
    conn.guides = [{ type:'V', pos:x }];
  }
}
  </script>

  <!-- Help FAB + '?' key -->
  <script>
    (function(){
      const dlg = document.getElementById('helpDialog');
      const btn = document.getElementById('helpToggle');

      function toggleHelp(){
        if (!dlg.open) dlg.showModal(); else dlg.close();
      }
      btn.addEventListener('click', toggleHelp);

      // Make "Close" button work
      const closeBtn = dlg.querySelector('.help-close');
      if (closeBtn) closeBtn.addEventListener('click', ()=> dlg.close());

      function isTypingTarget(el){
        if (!el) return false;
        const tag = el.tagName?.toLowerCase();
        return tag === 'input' || tag === 'textarea' || el.isContentEditable;
      }
      window.addEventListener('keydown', (e)=>{
        if (isTypingTarget(document.activeElement)) return;
        const isQ = e.key === '?' || (e.key === '/' && e.shiftKey) || (e.code === 'Slash' && e.shiftKey);
        if (!isQ) return;
        e.preventDefault();
        toggleHelp();
      });
    })();
  </script>
</body>
</html>
